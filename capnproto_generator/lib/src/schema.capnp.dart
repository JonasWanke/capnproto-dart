// GENERATED CODE - DO NOT MODIFY BY HAND
// Generated by the capnpc-dart plugin to the Cap'n Proto schema compiler.
// Source: lib/src/schema/schema.capnp

// ignore_for_file: avoid_setters_without_getters, avoid_js_rounded_ints, lines_longer_than_80_chars
// ignore_for_file: camel_case_types, directives_ordering

import 'dart:core' as $core;
import 'dart:typed_data' as $typed_data;

import 'package:capnproto/capnproto.dart' as $capnproto;

// struct Node

class Node_Reader extends $capnproto.CapnpStructReader {
  const Node_Reader(super.reader);

  static const typeId = -1836717350928014313;

  $core.int get id => reader.getUInt64(0, 0);

  $core.bool get hasDisplayName => !reader.getPointer(0).isNull;

  /// Name to present to humans to identify this Node.  You should not attempt to parse this.  Its
  /// format could change.  It is not guaranteed to be unique.
  ///
  /// (On Zooko's triangle, this is the node's nickname.)
  $core.String get displayName => reader.getPointer(0).getText(null).unwrap();

  /// If you want a shorter version of `displayName` (just naming this node, without its surrounding
  /// scope), chop off this many characters from the beginning of `displayName`.
  $core.int get displayNamePrefixLength => reader.getUInt32(2, 0);

  /// ID of the lexical parent node.  Typically, the scope node will have a NestedNode pointing back
  /// at this node, but robust code should avoid relying on this (and, in fact, group nodes are not
  /// listed in the outer struct's nestedNodes, since they are listed in the fields).  `scopeId` is
  /// zero if the node has no parent, which is normally only the case with files, but should be
  /// allowed for any kind of node (in order to make runtime type generation easier).
  $core.int get scopeId => reader.getUInt64(2, 0);

  $core.bool get hasNestedNodes => !reader.getPointer(1).isNull;

  /// List of nodes nested within this node, along with the names under which they were declared.
  $capnproto.StructListReader<Node_NestedNode_Reader> get nestedNodes {
    return $capnproto.StructListReader.getFromPointer(
      reader.getPointer(1),
      Node_NestedNode_Reader.new,
      null,
    ).unwrap();
  }

  $core.bool get hasAnnotations => !reader.getPointer(2).isNull;

  /// Annotations applied to this node.
  $capnproto.StructListReader<Annotation_Reader> get annotations {
    return $capnproto.StructListReader.getFromPointer(
      reader.getPointer(2),
      Annotation_Reader.new,
      null,
    ).unwrap();
  }

  $core.bool get hasParameters => !reader.getPointer(5).isNull;

  /// If this node is parameterized (generic), the list of parameters. Empty for non-generic types.
  $capnproto.StructListReader<Node_Parameter_Reader> get parameters {
    return $capnproto.StructListReader.getFromPointer(
      reader.getPointer(5),
      Node_Parameter_Reader.new,
      null,
    ).unwrap();
  }

  /// True if this node is generic, meaning that it or one of its parent scopes has a non-empty
  /// `parameters`.
  $core.bool get isGeneric => reader.getBool(288, false);

  Node_union_Reader get which {
    return switch (reader.getUInt16(6, 0)) {
      0 => Node_file_Reader(reader),
      1 => Node_struct_Reader(reader),
      2 => Node_enum_Reader(reader),
      3 => Node_interface_Reader(reader),
      4 => Node_const_Reader(reader),
      5 => Node_annotation_Reader(reader),
      _ => Node_notInSchema_Reader(reader),
    };
  }
}

sealed class Node_union_Reader extends $capnproto.CapnpStructReader {
  const Node_union_Reader(super.reader);
}

class Node_Builder extends $capnproto.CapnpStructBuilder<Node_Reader> {
  const Node_Builder(super.builder);

  Node_Builder.initPointer($capnproto.PointerBuilder builder)
      : this(builder.initStruct(structSize));

  Node_Builder.getFromPointer(
    $capnproto.PointerBuilder builder,
    $typed_data.ByteData defaultValue,
  ) : this(builder.getStruct(structSize, defaultValue).unwrap());

  static const structSize =
      $capnproto.StructSize(dataWords: 5, pointerCount: 6);

  @$core.override
  Node_Reader get asReader => Node_Reader(builder.asReader);

  $core.int get id {
    return builder.getUInt64(0, 0);
  }

  set id($core.int value) {
    return builder.setUInt64(0, value, 0);
  }

  $core.bool get hasDisplayName => !builder.getPointer(0).isNull;

  /// Name to present to humans to identify this Node.  You should not attempt to parse this.  Its
  /// format could change.  It is not guaranteed to be unique.
  ///
  /// (On Zooko's triangle, this is the node's nickname.)
  $core.String get displayName => builder.getPointer(0).getText(null).unwrap();
  set displayName($core.String value) {
    builder.getPointer(0).setText(value);
  }

  /// If you want a shorter version of `displayName` (just naming this node, without its surrounding
  /// scope), chop off this many characters from the beginning of `displayName`.
  $core.int get displayNamePrefixLength {
    return builder.getUInt32(2, 0);
  }

  set displayNamePrefixLength($core.int value) {
    return builder.setUInt32(2, value, 0);
  }

  /// ID of the lexical parent node.  Typically, the scope node will have a NestedNode pointing back
  /// at this node, but robust code should avoid relying on this (and, in fact, group nodes are not
  /// listed in the outer struct's nestedNodes, since they are listed in the fields).  `scopeId` is
  /// zero if the node has no parent, which is normally only the case with files, but should be
  /// allowed for any kind of node (in order to make runtime type generation easier).
  $core.int get scopeId {
    return builder.getUInt64(2, 0);
  }

  set scopeId($core.int value) {
    return builder.setUInt64(2, value, 0);
  }

  $core.bool get hasNestedNodes => !builder.getPointer(1).isNull;

  /// List of nodes nested within this node, along with the names under which they were declared.
  $capnproto.StructListBuilder<Node_NestedNode_Builder, Node_NestedNode_Reader>
      get nestedNodes {
    return $capnproto.StructListBuilder.getFromPointer(
      builder.getPointer(1),
      Node_NestedNode_Builder.structSize,
      Node_NestedNode_Builder.new,
      Node_NestedNode_Reader.new,
      null,
    ).unwrap();
  }

  $capnproto.StructListBuilder<Node_NestedNode_Builder, Node_NestedNode_Reader>
      initNestedNodes($core.int length) {
    return $capnproto.StructListBuilder.initPointer(
      builder.getPointer(1),
      length,
      Node_NestedNode_Builder.structSize,
      Node_NestedNode_Builder.new,
      Node_NestedNode_Reader.new,
    );
  }

  $core.bool get hasAnnotations => !builder.getPointer(2).isNull;

  /// Annotations applied to this node.
  $capnproto.StructListBuilder<Annotation_Builder, Annotation_Reader>
      get annotations {
    return $capnproto.StructListBuilder.getFromPointer(
      builder.getPointer(2),
      Annotation_Builder.structSize,
      Annotation_Builder.new,
      Annotation_Reader.new,
      null,
    ).unwrap();
  }

  $capnproto.StructListBuilder<Annotation_Builder, Annotation_Reader>
      initAnnotations($core.int length) {
    return $capnproto.StructListBuilder.initPointer(
      builder.getPointer(2),
      length,
      Annotation_Builder.structSize,
      Annotation_Builder.new,
      Annotation_Reader.new,
    );
  }

  $core.bool get hasParameters => !builder.getPointer(5).isNull;

  /// If this node is parameterized (generic), the list of parameters. Empty for non-generic types.
  $capnproto.StructListBuilder<Node_Parameter_Builder, Node_Parameter_Reader>
      get parameters {
    return $capnproto.StructListBuilder.getFromPointer(
      builder.getPointer(5),
      Node_Parameter_Builder.structSize,
      Node_Parameter_Builder.new,
      Node_Parameter_Reader.new,
      null,
    ).unwrap();
  }

  $capnproto.StructListBuilder<Node_Parameter_Builder, Node_Parameter_Reader>
      initParameters($core.int length) {
    return $capnproto.StructListBuilder.initPointer(
      builder.getPointer(5),
      length,
      Node_Parameter_Builder.structSize,
      Node_Parameter_Builder.new,
      Node_Parameter_Reader.new,
    );
  }

  /// True if this node is generic, meaning that it or one of its parent scopes has a non-empty
  /// `parameters`.
  $core.bool get isGeneric {
    return builder.getBool(288, false);
  }

  set isGeneric($core.bool value) {
    return builder.setBool(288, value, false);
  }

  void setFile() {
    builder.setUInt16(6, 0, 0);
  }

  Node_struct_Builder initStruct() {
    builder.setUInt16(6, 1, 0);
    return Node_struct_Builder(builder);
  }

  Node_enum_Builder initEnum() {
    builder.setUInt16(6, 2, 0);
    return Node_enum_Builder(builder);
  }

  Node_interface_Builder initInterface() {
    builder.setUInt16(6, 3, 0);
    return Node_interface_Builder(builder);
  }

  Node_const_Builder initConst() {
    builder.setUInt16(6, 4, 0);
    return Node_const_Builder(builder);
  }

  Node_annotation_Builder initAnnotation() {
    builder.setUInt16(6, 5, 0);
    return Node_annotation_Builder(builder);
  }

  Node_union_Builder get which {
    return switch (builder.getUInt16(6, 0)) {
      0 => Node_file_Builder(builder),
      1 => Node_struct_Builder(builder),
      2 => Node_enum_Builder(builder),
      3 => Node_interface_Builder(builder),
      4 => Node_const_Builder(builder),
      5 => Node_annotation_Builder(builder),
      _ => Node_notInSchema_Builder(builder),
    };
  }
}

sealed class Node_union_Builder<R extends Node_union_Reader>
    extends $capnproto.CapnpStructBuilder<R> {
  const Node_union_Builder(super.builder);
}

class Node_file_Reader extends Node_union_Reader {
  const Node_file_Reader(super.reader);

  void get value {}
}

class Node_file_Builder extends Node_union_Builder {
  const Node_file_Builder(super.builder);

  @$core.override
  Node_file_Reader get asReader => Node_file_Reader(builder.asReader);

  void get value {}
}

// group Node.struct

class Node_struct_Reader extends Node_union_Reader {
  const Node_struct_Reader(super.reader);

  static const typeId = -7016412939225971659;

  /// Size of the data section, in words.
  $core.int get dataWordCount => reader.getUInt16(7, 0);

  /// Size of the pointer section, in pointers (which are one word each).
  $core.int get pointerCount => reader.getUInt16(12, 0);

  /// The preferred element size to use when encoding a list of this struct.  If this is anything
  /// other than `inlineComposite` then the struct is one word or less in size and is a candidate
  /// for list packing optimization.
  ElementSize get preferredListEncoding =>
      ElementSize.fromValue(reader.getUInt16(13, 0));

  /// If true, then this "struct" node is actually not an independent node, but merely represents
  /// some named union or group within a particular parent struct.  This node's scopeId refers
  /// to the parent struct, which may itself be a union/group in yet another struct.
  ///
  /// All group nodes share the same dataWordCount and pointerCount as the top-level
  /// struct, and their fields live in the same ordinal and offset spaces as all other fields in
  /// the struct.
  ///
  /// Note that a named union is considered a special kind of group -- in fact, a named union
  /// is exactly equivalent to a group that contains nothing but an unnamed union.
  $core.bool get isGroup => reader.getBool(224, false);

  /// Number of fields in this struct which are members of an anonymous union, and thus may
  /// overlap.  If this is non-zero, then a 16-bit discriminant is present indicating which
  /// of the overlapping fields is active.  This can never be 1 -- if it is non-zero, it must be
  /// two or more.
  ///
  /// Note that the fields of an unnamed union are considered fields of the scope containing the
  /// union -- an unnamed union is not its own group.  So, a top-level struct may contain a
  /// non-zero discriminant count.  Named unions, on the other hand, are equivalent to groups
  /// containing unnamed unions.  So, a named union has its own independent schema node, with
  /// `isGroup` = true.
  $core.int get discriminantCount => reader.getUInt16(15, 0);

  /// If `discriminantCount` is non-zero, this is the offset of the union discriminant, in
  /// multiples of 16 bits.
  $core.int get discriminantOffset => reader.getUInt32(8, 0);

  $core.bool get hasFields => !reader.getPointer(3).isNull;

  /// Fields defined within this scope (either the struct's top-level fields, or the fields of
  /// a particular group; see `isGroup`).
  ///
  /// The fields are sorted by ordinal number, but note that because groups share the same
  /// ordinal space, the field's index in this list is not necessarily exactly its ordinal.
  /// On the other hand, the field's position in this list does remain the same even as the
  /// protocol evolves, since it is not possible to insert or remove an earlier ordinal.
  /// Therefore, for most use cases, if you want to identify a field by number, it may make the
  /// most sense to use the field's index in this list rather than its ordinal.
  $capnproto.StructListReader<Field_Reader> get fields {
    return $capnproto.StructListReader.getFromPointer(
      reader.getPointer(3),
      Field_Reader.new,
      null,
    ).unwrap();
  }
}

class Node_struct_Builder extends Node_union_Builder<Node_struct_Reader> {
  const Node_struct_Builder(super.builder);

  Node_struct_Builder.initPointer($capnproto.PointerBuilder builder)
      : this(builder.initStruct(structSize));

  Node_struct_Builder.getFromPointer(
    $capnproto.PointerBuilder builder,
    $typed_data.ByteData defaultValue,
  ) : this(builder.getStruct(structSize, defaultValue).unwrap());

  static const structSize =
      $capnproto.StructSize(dataWords: 5, pointerCount: 6);

  @$core.override
  Node_struct_Reader get asReader => Node_struct_Reader(builder.asReader);

  /// Size of the data section, in words.
  $core.int get dataWordCount {
    return builder.getUInt16(7, 0);
  }

  set dataWordCount($core.int value) {
    return builder.setUInt16(7, value, 0);
  }

  /// Size of the pointer section, in pointers (which are one word each).
  $core.int get pointerCount {
    return builder.getUInt16(12, 0);
  }

  set pointerCount($core.int value) {
    return builder.setUInt16(12, value, 0);
  }

  /// The preferred element size to use when encoding a list of this struct.  If this is anything
  /// other than `inlineComposite` then the struct is one word or less in size and is a candidate
  /// for list packing optimization.
  ElementSize get preferredListEncoding =>
      ElementSize.fromValue(builder.getUInt16(13, 0));
  set preferredListEncoding(ElementSize value) {
    assert(value != ElementSize.notInSchema);
    builder.setUInt16(13, value.value!, 0);
  }

  /// If true, then this "struct" node is actually not an independent node, but merely represents
  /// some named union or group within a particular parent struct.  This node's scopeId refers
  /// to the parent struct, which may itself be a union/group in yet another struct.
  ///
  /// All group nodes share the same dataWordCount and pointerCount as the top-level
  /// struct, and their fields live in the same ordinal and offset spaces as all other fields in
  /// the struct.
  ///
  /// Note that a named union is considered a special kind of group -- in fact, a named union
  /// is exactly equivalent to a group that contains nothing but an unnamed union.
  $core.bool get isGroup {
    return builder.getBool(224, false);
  }

  set isGroup($core.bool value) {
    return builder.setBool(224, value, false);
  }

  /// Number of fields in this struct which are members of an anonymous union, and thus may
  /// overlap.  If this is non-zero, then a 16-bit discriminant is present indicating which
  /// of the overlapping fields is active.  This can never be 1 -- if it is non-zero, it must be
  /// two or more.
  ///
  /// Note that the fields of an unnamed union are considered fields of the scope containing the
  /// union -- an unnamed union is not its own group.  So, a top-level struct may contain a
  /// non-zero discriminant count.  Named unions, on the other hand, are equivalent to groups
  /// containing unnamed unions.  So, a named union has its own independent schema node, with
  /// `isGroup` = true.
  $core.int get discriminantCount {
    return builder.getUInt16(15, 0);
  }

  set discriminantCount($core.int value) {
    return builder.setUInt16(15, value, 0);
  }

  /// If `discriminantCount` is non-zero, this is the offset of the union discriminant, in
  /// multiples of 16 bits.
  $core.int get discriminantOffset {
    return builder.getUInt32(8, 0);
  }

  set discriminantOffset($core.int value) {
    return builder.setUInt32(8, value, 0);
  }

  $core.bool get hasFields => !builder.getPointer(3).isNull;

  /// Fields defined within this scope (either the struct's top-level fields, or the fields of
  /// a particular group; see `isGroup`).
  ///
  /// The fields are sorted by ordinal number, but note that because groups share the same
  /// ordinal space, the field's index in this list is not necessarily exactly its ordinal.
  /// On the other hand, the field's position in this list does remain the same even as the
  /// protocol evolves, since it is not possible to insert or remove an earlier ordinal.
  /// Therefore, for most use cases, if you want to identify a field by number, it may make the
  /// most sense to use the field's index in this list rather than its ordinal.
  $capnproto.StructListBuilder<Field_Builder, Field_Reader> get fields {
    return $capnproto.StructListBuilder.getFromPointer(
      builder.getPointer(3),
      Field_Builder.structSize,
      Field_Builder.new,
      Field_Reader.new,
      null,
    ).unwrap();
  }

  $capnproto.StructListBuilder<Field_Builder, Field_Reader> initFields(
    $core.int length,
  ) {
    return $capnproto.StructListBuilder.initPointer(
      builder.getPointer(3),
      length,
      Field_Builder.structSize,
      Field_Builder.new,
      Field_Reader.new,
    );
  }
}

// group Node.enum

class Node_enum_Reader extends Node_union_Reader {
  const Node_enum_Reader(super.reader);

  static const typeId = -5383293358930922088;

  $core.bool get hasEnumerants => !reader.getPointer(3).isNull;

  /// Enumerants ordered by numeric value (ordinal).
  $capnproto.StructListReader<Enumerant_Reader> get enumerants {
    return $capnproto.StructListReader.getFromPointer(
      reader.getPointer(3),
      Enumerant_Reader.new,
      null,
    ).unwrap();
  }
}

class Node_enum_Builder extends Node_union_Builder<Node_enum_Reader> {
  const Node_enum_Builder(super.builder);

  Node_enum_Builder.initPointer($capnproto.PointerBuilder builder)
      : this(builder.initStruct(structSize));

  Node_enum_Builder.getFromPointer(
    $capnproto.PointerBuilder builder,
    $typed_data.ByteData defaultValue,
  ) : this(builder.getStruct(structSize, defaultValue).unwrap());

  static const structSize =
      $capnproto.StructSize(dataWords: 5, pointerCount: 6);

  @$core.override
  Node_enum_Reader get asReader => Node_enum_Reader(builder.asReader);

  $core.bool get hasEnumerants => !builder.getPointer(3).isNull;

  /// Enumerants ordered by numeric value (ordinal).
  $capnproto.StructListBuilder<Enumerant_Builder, Enumerant_Reader>
      get enumerants {
    return $capnproto.StructListBuilder.getFromPointer(
      builder.getPointer(3),
      Enumerant_Builder.structSize,
      Enumerant_Builder.new,
      Enumerant_Reader.new,
      null,
    ).unwrap();
  }

  $capnproto.StructListBuilder<Enumerant_Builder, Enumerant_Reader>
      initEnumerants($core.int length) {
    return $capnproto.StructListBuilder.initPointer(
      builder.getPointer(3),
      length,
      Enumerant_Builder.structSize,
      Enumerant_Builder.new,
      Enumerant_Reader.new,
    );
  }
}

// group Node.interface

class Node_interface_Reader extends Node_union_Reader {
  const Node_interface_Reader(super.reader);

  static const typeId = -1718312580255964785;

  $core.bool get hasMethods => !reader.getPointer(3).isNull;

  /// Methods ordered by ordinal.
  $capnproto.StructListReader<Method_Reader> get methods {
    return $capnproto.StructListReader.getFromPointer(
      reader.getPointer(3),
      Method_Reader.new,
      null,
    ).unwrap();
  }

  $core.bool get hasSuperclasses => !reader.getPointer(4).isNull;

  /// Superclasses of this interface.
  $capnproto.StructListReader<Superclass_Reader> get superclasses {
    return $capnproto.StructListReader.getFromPointer(
      reader.getPointer(4),
      Superclass_Reader.new,
      null,
    ).unwrap();
  }
}

class Node_interface_Builder extends Node_union_Builder<Node_interface_Reader> {
  const Node_interface_Builder(super.builder);

  Node_interface_Builder.initPointer($capnproto.PointerBuilder builder)
      : this(builder.initStruct(structSize));

  Node_interface_Builder.getFromPointer(
    $capnproto.PointerBuilder builder,
    $typed_data.ByteData defaultValue,
  ) : this(builder.getStruct(structSize, defaultValue).unwrap());

  static const structSize =
      $capnproto.StructSize(dataWords: 5, pointerCount: 6);

  @$core.override
  Node_interface_Reader get asReader => Node_interface_Reader(builder.asReader);

  $core.bool get hasMethods => !builder.getPointer(3).isNull;

  /// Methods ordered by ordinal.
  $capnproto.StructListBuilder<Method_Builder, Method_Reader> get methods {
    return $capnproto.StructListBuilder.getFromPointer(
      builder.getPointer(3),
      Method_Builder.structSize,
      Method_Builder.new,
      Method_Reader.new,
      null,
    ).unwrap();
  }

  $capnproto.StructListBuilder<Method_Builder, Method_Reader> initMethods(
    $core.int length,
  ) {
    return $capnproto.StructListBuilder.initPointer(
      builder.getPointer(3),
      length,
      Method_Builder.structSize,
      Method_Builder.new,
      Method_Reader.new,
    );
  }

  $core.bool get hasSuperclasses => !builder.getPointer(4).isNull;

  /// Superclasses of this interface.
  $capnproto.StructListBuilder<Superclass_Builder, Superclass_Reader>
      get superclasses {
    return $capnproto.StructListBuilder.getFromPointer(
      builder.getPointer(4),
      Superclass_Builder.structSize,
      Superclass_Builder.new,
      Superclass_Reader.new,
      null,
    ).unwrap();
  }

  $capnproto.StructListBuilder<Superclass_Builder, Superclass_Reader>
      initSuperclasses($core.int length) {
    return $capnproto.StructListBuilder.initPointer(
      builder.getPointer(4),
      length,
      Superclass_Builder.structSize,
      Superclass_Builder.new,
      Superclass_Reader.new,
    );
  }
}

// group Node.const

class Node_const_Reader extends Node_union_Reader {
  const Node_const_Reader(super.reader);

  static const typeId = -5653524222009568224;

  $core.bool get hasType_ => !reader.getPointer(3).isNull;
  Type_Reader get type =>
      Type_Reader(reader.getPointer(3).getStruct(null).unwrap());

  $core.bool get hasValue => !reader.getPointer(4).isNull;
  Value_Reader get value =>
      Value_Reader(reader.getPointer(4).getStruct(null).unwrap());
}

class Node_const_Builder extends Node_union_Builder<Node_const_Reader> {
  const Node_const_Builder(super.builder);

  Node_const_Builder.initPointer($capnproto.PointerBuilder builder)
      : this(builder.initStruct(structSize));

  Node_const_Builder.getFromPointer(
    $capnproto.PointerBuilder builder,
    $typed_data.ByteData defaultValue,
  ) : this(builder.getStruct(structSize, defaultValue).unwrap());

  static const structSize =
      $capnproto.StructSize(dataWords: 5, pointerCount: 6);

  @$core.override
  Node_const_Reader get asReader => Node_const_Reader(builder.asReader);

  $core.bool get hasType_ => !builder.getPointer(3).isNull;
  Type_Builder getType_() {
    return Type_Builder(
      builder.getPointer(3).getStruct(Type_Builder.structSize, null).unwrap(),
    );
  }

  Type_Builder initType_() {
    return Type_Builder(
      builder.getPointer(3).initStruct(Type_Builder.structSize),
    );
  }

  $core.bool get hasValue => !builder.getPointer(4).isNull;
  Value_Builder getValue() {
    return Value_Builder(
      builder.getPointer(4).getStruct(Value_Builder.structSize, null).unwrap(),
    );
  }

  Value_Builder initValue() {
    return Value_Builder(
      builder.getPointer(4).initStruct(Value_Builder.structSize),
    );
  }
}

// group Node.annotation

class Node_annotation_Reader extends Node_union_Reader {
  const Node_annotation_Reader(super.reader);

  static const typeId = -1434931031872765296;

  $core.bool get hasType_ => !reader.getPointer(3).isNull;
  Type_Reader get type =>
      Type_Reader(reader.getPointer(3).getStruct(null).unwrap());

  $core.bool get targetsFile => reader.getBool(112, false);

  $core.bool get targetsConst => reader.getBool(113, false);

  $core.bool get targetsEnum => reader.getBool(114, false);

  $core.bool get targetsEnumerant => reader.getBool(115, false);

  $core.bool get targetsStruct => reader.getBool(116, false);

  $core.bool get targetsField => reader.getBool(117, false);

  $core.bool get targetsUnion => reader.getBool(118, false);

  $core.bool get targetsGroup => reader.getBool(119, false);

  $core.bool get targetsInterface => reader.getBool(120, false);

  $core.bool get targetsMethod => reader.getBool(121, false);

  $core.bool get targetsParam => reader.getBool(122, false);

  $core.bool get targetsAnnotation => reader.getBool(123, false);
}

class Node_annotation_Builder
    extends Node_union_Builder<Node_annotation_Reader> {
  const Node_annotation_Builder(super.builder);

  Node_annotation_Builder.initPointer($capnproto.PointerBuilder builder)
      : this(builder.initStruct(structSize));

  Node_annotation_Builder.getFromPointer(
    $capnproto.PointerBuilder builder,
    $typed_data.ByteData defaultValue,
  ) : this(builder.getStruct(structSize, defaultValue).unwrap());

  static const structSize =
      $capnproto.StructSize(dataWords: 5, pointerCount: 6);

  @$core.override
  Node_annotation_Reader get asReader =>
      Node_annotation_Reader(builder.asReader);

  $core.bool get hasType_ => !builder.getPointer(3).isNull;
  Type_Builder getType_() {
    return Type_Builder(
      builder.getPointer(3).getStruct(Type_Builder.structSize, null).unwrap(),
    );
  }

  Type_Builder initType_() {
    return Type_Builder(
      builder.getPointer(3).initStruct(Type_Builder.structSize),
    );
  }

  $core.bool get targetsFile {
    return builder.getBool(112, false);
  }

  set targetsFile($core.bool value) {
    return builder.setBool(112, value, false);
  }

  $core.bool get targetsConst {
    return builder.getBool(113, false);
  }

  set targetsConst($core.bool value) {
    return builder.setBool(113, value, false);
  }

  $core.bool get targetsEnum {
    return builder.getBool(114, false);
  }

  set targetsEnum($core.bool value) {
    return builder.setBool(114, value, false);
  }

  $core.bool get targetsEnumerant {
    return builder.getBool(115, false);
  }

  set targetsEnumerant($core.bool value) {
    return builder.setBool(115, value, false);
  }

  $core.bool get targetsStruct {
    return builder.getBool(116, false);
  }

  set targetsStruct($core.bool value) {
    return builder.setBool(116, value, false);
  }

  $core.bool get targetsField {
    return builder.getBool(117, false);
  }

  set targetsField($core.bool value) {
    return builder.setBool(117, value, false);
  }

  $core.bool get targetsUnion {
    return builder.getBool(118, false);
  }

  set targetsUnion($core.bool value) {
    return builder.setBool(118, value, false);
  }

  $core.bool get targetsGroup {
    return builder.getBool(119, false);
  }

  set targetsGroup($core.bool value) {
    return builder.setBool(119, value, false);
  }

  $core.bool get targetsInterface {
    return builder.getBool(120, false);
  }

  set targetsInterface($core.bool value) {
    return builder.setBool(120, value, false);
  }

  $core.bool get targetsMethod {
    return builder.getBool(121, false);
  }

  set targetsMethod($core.bool value) {
    return builder.setBool(121, value, false);
  }

  $core.bool get targetsParam {
    return builder.getBool(122, false);
  }

  set targetsParam($core.bool value) {
    return builder.setBool(122, value, false);
  }

  $core.bool get targetsAnnotation {
    return builder.getBool(123, false);
  }

  set targetsAnnotation($core.bool value) {
    return builder.setBool(123, value, false);
  }
}

class Node_notInSchema_Reader extends Node_union_Reader {
  const Node_notInSchema_Reader(super.reader);
}

class Node_notInSchema_Builder extends Node_union_Builder {
  const Node_notInSchema_Builder(super.reader);

  @$core.override
  Node_notInSchema_Reader get asReader =>
      Node_notInSchema_Reader(builder.asReader);
}

// struct Node.Parameter

/// Information about one of the node's parameters.
class Node_Parameter_Reader extends $capnproto.CapnpStructReader {
  const Node_Parameter_Reader(super.reader);

  static const typeId = -5092977661570997327;

  $core.bool get hasName => !reader.getPointer(0).isNull;
  $core.String get name => reader.getPointer(0).getText(null).unwrap();
}

/// Information about one of the node's parameters.
class Node_Parameter_Builder
    extends $capnproto.CapnpStructBuilder<Node_Parameter_Reader> {
  const Node_Parameter_Builder(super.builder);

  Node_Parameter_Builder.initPointer($capnproto.PointerBuilder builder)
      : this(builder.initStruct(structSize));

  Node_Parameter_Builder.getFromPointer(
    $capnproto.PointerBuilder builder,
    $typed_data.ByteData defaultValue,
  ) : this(builder.getStruct(structSize, defaultValue).unwrap());

  static const structSize =
      $capnproto.StructSize(dataWords: 0, pointerCount: 1);

  @$core.override
  Node_Parameter_Reader get asReader => Node_Parameter_Reader(builder.asReader);

  $core.bool get hasName => !builder.getPointer(0).isNull;
  $core.String get name => builder.getPointer(0).getText(null).unwrap();
  set name($core.String value) {
    builder.getPointer(0).setText(value);
  }
}

// struct Node.NestedNode

class Node_NestedNode_Reader extends $capnproto.CapnpStructReader {
  const Node_NestedNode_Reader(super.reader);

  static const typeId = -2396102210895232446;

  $core.bool get hasName => !reader.getPointer(0).isNull;

  /// Unqualified symbol name.  Unlike Node.displayName, this *can* be used programmatically.
  ///
  /// (On Zooko's triangle, this is the node's petname according to its parent scope.)
  $core.String get name => reader.getPointer(0).getText(null).unwrap();

  /// ID of the nested node.  Typically, the target node's scopeId points back to this node, but
  /// robust code should avoid relying on this.
  $core.int get id => reader.getUInt64(0, 0);
}

class Node_NestedNode_Builder
    extends $capnproto.CapnpStructBuilder<Node_NestedNode_Reader> {
  const Node_NestedNode_Builder(super.builder);

  Node_NestedNode_Builder.initPointer($capnproto.PointerBuilder builder)
      : this(builder.initStruct(structSize));

  Node_NestedNode_Builder.getFromPointer(
    $capnproto.PointerBuilder builder,
    $typed_data.ByteData defaultValue,
  ) : this(builder.getStruct(structSize, defaultValue).unwrap());

  static const structSize =
      $capnproto.StructSize(dataWords: 1, pointerCount: 1);

  @$core.override
  Node_NestedNode_Reader get asReader =>
      Node_NestedNode_Reader(builder.asReader);

  $core.bool get hasName => !builder.getPointer(0).isNull;

  /// Unqualified symbol name.  Unlike Node.displayName, this *can* be used programmatically.
  ///
  /// (On Zooko's triangle, this is the node's petname according to its parent scope.)
  $core.String get name => builder.getPointer(0).getText(null).unwrap();
  set name($core.String value) {
    builder.getPointer(0).setText(value);
  }

  /// ID of the nested node.  Typically, the target node's scopeId points back to this node, but
  /// robust code should avoid relying on this.
  $core.int get id {
    return builder.getUInt64(0, 0);
  }

  set id($core.int value) {
    return builder.setUInt64(0, value, 0);
  }
}

// struct Node.SourceInfo

/// Additional information about a node which is not needed at runtime, but may be useful for
/// documentation or debugging purposes. This is kept in a separate struct to make sure it
/// doesn't accidentally get included in contexts where it is not needed. The
/// `CodeGeneratorRequest` includes this information in a separate array.
class Node_SourceInfo_Reader extends $capnproto.CapnpStructReader {
  const Node_SourceInfo_Reader(super.reader);

  static const typeId = -896746414936991826;

  /// ID of the Node which this info describes.
  $core.int get id => reader.getUInt64(0, 0);

  $core.bool get hasDocComment => !reader.getPointer(0).isNull;

  /// The top-level doc comment for the Node.
  $core.String get docComment => reader.getPointer(0).getText(null).unwrap();

  $core.bool get hasMembers => !reader.getPointer(1).isNull;

  /// Information about each member -- i.e. fields (for structs), enumerants (for enums), or
  /// methods (for interfaces).
  ///
  /// This list is the same length and order as the corresponding list in the Node, i.e.
  /// Node.struct.fields, Node.enum.enumerants, or Node.interface.methods.
  $capnproto.StructListReader<Node_SourceInfo_Member_Reader> get members {
    return $capnproto.StructListReader.getFromPointer(
      reader.getPointer(1),
      Node_SourceInfo_Member_Reader.new,
      null,
    ).unwrap();
  }
}

/// Additional information about a node which is not needed at runtime, but may be useful for
/// documentation or debugging purposes. This is kept in a separate struct to make sure it
/// doesn't accidentally get included in contexts where it is not needed. The
/// `CodeGeneratorRequest` includes this information in a separate array.
class Node_SourceInfo_Builder
    extends $capnproto.CapnpStructBuilder<Node_SourceInfo_Reader> {
  const Node_SourceInfo_Builder(super.builder);

  Node_SourceInfo_Builder.initPointer($capnproto.PointerBuilder builder)
      : this(builder.initStruct(structSize));

  Node_SourceInfo_Builder.getFromPointer(
    $capnproto.PointerBuilder builder,
    $typed_data.ByteData defaultValue,
  ) : this(builder.getStruct(structSize, defaultValue).unwrap());

  static const structSize =
      $capnproto.StructSize(dataWords: 1, pointerCount: 2);

  @$core.override
  Node_SourceInfo_Reader get asReader =>
      Node_SourceInfo_Reader(builder.asReader);

  /// ID of the Node which this info describes.
  $core.int get id {
    return builder.getUInt64(0, 0);
  }

  set id($core.int value) {
    return builder.setUInt64(0, value, 0);
  }

  $core.bool get hasDocComment => !builder.getPointer(0).isNull;

  /// The top-level doc comment for the Node.
  $core.String get docComment => builder.getPointer(0).getText(null).unwrap();
  set docComment($core.String value) {
    builder.getPointer(0).setText(value);
  }

  $core.bool get hasMembers => !builder.getPointer(1).isNull;

  /// Information about each member -- i.e. fields (for structs), enumerants (for enums), or
  /// methods (for interfaces).
  ///
  /// This list is the same length and order as the corresponding list in the Node, i.e.
  /// Node.struct.fields, Node.enum.enumerants, or Node.interface.methods.
  $capnproto.StructListBuilder<Node_SourceInfo_Member_Builder,
      Node_SourceInfo_Member_Reader> get members {
    return $capnproto.StructListBuilder.getFromPointer(
      builder.getPointer(1),
      Node_SourceInfo_Member_Builder.structSize,
      Node_SourceInfo_Member_Builder.new,
      Node_SourceInfo_Member_Reader.new,
      null,
    ).unwrap();
  }

  $capnproto.StructListBuilder<Node_SourceInfo_Member_Builder,
      Node_SourceInfo_Member_Reader> initMembers($core.int length) {
    return $capnproto.StructListBuilder.initPointer(
      builder.getPointer(1),
      length,
      Node_SourceInfo_Member_Builder.structSize,
      Node_SourceInfo_Member_Builder.new,
      Node_SourceInfo_Member_Reader.new,
    );
  }
}

// struct Node.SourceInfo.Member

class Node_SourceInfo_Member_Reader extends $capnproto.CapnpStructReader {
  const Node_SourceInfo_Member_Reader(super.reader);

  static const typeId = -4415057912182988894;

  $core.bool get hasDocComment => !reader.getPointer(0).isNull;

  /// Doc comment on the member.
  $core.String get docComment => reader.getPointer(0).getText(null).unwrap();
}

class Node_SourceInfo_Member_Builder
    extends $capnproto.CapnpStructBuilder<Node_SourceInfo_Member_Reader> {
  const Node_SourceInfo_Member_Builder(super.builder);

  Node_SourceInfo_Member_Builder.initPointer($capnproto.PointerBuilder builder)
      : this(builder.initStruct(structSize));

  Node_SourceInfo_Member_Builder.getFromPointer(
    $capnproto.PointerBuilder builder,
    $typed_data.ByteData defaultValue,
  ) : this(builder.getStruct(structSize, defaultValue).unwrap());

  static const structSize =
      $capnproto.StructSize(dataWords: 0, pointerCount: 1);

  @$core.override
  Node_SourceInfo_Member_Reader get asReader =>
      Node_SourceInfo_Member_Reader(builder.asReader);

  $core.bool get hasDocComment => !builder.getPointer(0).isNull;

  /// Doc comment on the member.
  $core.String get docComment => builder.getPointer(0).getText(null).unwrap();
  set docComment($core.String value) {
    builder.getPointer(0).setText(value);
  }
}

// struct Field

/// Schema for a field of a struct.
class Field_Reader extends $capnproto.CapnpStructReader {
  const Field_Reader(super.reader);

  static const typeId = -7301090755067841441;

  static const noDiscriminant = 65535;

  $core.bool get hasName => !reader.getPointer(0).isNull;
  $core.String get name => reader.getPointer(0).getText(null).unwrap();

  /// Indicates where this member appeared in the code, relative to other members.
  /// Code ordering may have semantic relevance -- programmers tend to place related fields
  /// together.  So, using code ordering makes sense in human-readable formats where ordering is
  /// otherwise irrelevant, like JSON.  The values of codeOrder are tightly-packed, so the maximum
  /// value is count(members) - 1.  Fields that are members of a union are only ordered relative to
  /// the other members of that union, so the maximum value there is count(union.members).
  $core.int get codeOrder => reader.getUInt16(0, 0);

  $core.bool get hasAnnotations => !reader.getPointer(1).isNull;
  $capnproto.StructListReader<Annotation_Reader> get annotations {
    return $capnproto.StructListReader.getFromPointer(
      reader.getPointer(1),
      Annotation_Reader.new,
      null,
    ).unwrap();
  }

  /// Default value of [discriminantValue].
  static const defaultDiscriminantValue = 65535;

  /// If the field is in a union, this is the value which the union's discriminant should take when
  /// the field is active.  If the field is not in a union, this is 0xffff.
  $core.int get discriminantValue =>
      reader.getUInt16(1, defaultDiscriminantValue);

  Field_union_Reader get which {
    return switch (reader.getUInt16(4, 0)) {
      0 => Field_slot_Reader(reader),
      1 => Field_group_Reader(reader),
      _ => Field_notInSchema_Reader(reader),
    };
  }
}

sealed class Field_union_Reader extends $capnproto.CapnpStructReader {
  const Field_union_Reader(super.reader);
}

/// Schema for a field of a struct.
class Field_Builder extends $capnproto.CapnpStructBuilder<Field_Reader> {
  const Field_Builder(super.builder);

  Field_Builder.initPointer($capnproto.PointerBuilder builder)
      : this(builder.initStruct(structSize));

  Field_Builder.getFromPointer(
    $capnproto.PointerBuilder builder,
    $typed_data.ByteData defaultValue,
  ) : this(builder.getStruct(structSize, defaultValue).unwrap());

  static const structSize =
      $capnproto.StructSize(dataWords: 3, pointerCount: 4);

  @$core.override
  Field_Reader get asReader => Field_Reader(builder.asReader);

  $core.bool get hasName => !builder.getPointer(0).isNull;
  $core.String get name => builder.getPointer(0).getText(null).unwrap();
  set name($core.String value) {
    builder.getPointer(0).setText(value);
  }

  /// Indicates where this member appeared in the code, relative to other members.
  /// Code ordering may have semantic relevance -- programmers tend to place related fields
  /// together.  So, using code ordering makes sense in human-readable formats where ordering is
  /// otherwise irrelevant, like JSON.  The values of codeOrder are tightly-packed, so the maximum
  /// value is count(members) - 1.  Fields that are members of a union are only ordered relative to
  /// the other members of that union, so the maximum value there is count(union.members).
  $core.int get codeOrder {
    return builder.getUInt16(0, 0);
  }

  set codeOrder($core.int value) {
    return builder.setUInt16(0, value, 0);
  }

  $core.bool get hasAnnotations => !builder.getPointer(1).isNull;
  $capnproto.StructListBuilder<Annotation_Builder, Annotation_Reader>
      get annotations {
    return $capnproto.StructListBuilder.getFromPointer(
      builder.getPointer(1),
      Annotation_Builder.structSize,
      Annotation_Builder.new,
      Annotation_Reader.new,
      null,
    ).unwrap();
  }

  $capnproto.StructListBuilder<Annotation_Builder, Annotation_Reader>
      initAnnotations($core.int length) {
    return $capnproto.StructListBuilder.initPointer(
      builder.getPointer(1),
      length,
      Annotation_Builder.structSize,
      Annotation_Builder.new,
      Annotation_Reader.new,
    );
  }

  /// If the field is in a union, this is the value which the union's discriminant should take when
  /// the field is active.  If the field is not in a union, this is 0xffff.
  $core.int get discriminantValue {
    return builder.getUInt16(1, Field_Reader.defaultDiscriminantValue);
  }

  set discriminantValue($core.int value) {
    return builder.setUInt16(1, value, Field_Reader.defaultDiscriminantValue);
  }

  /// A regular, non-group, non-fixed-list field.
  Field_slot_Builder initSlot() {
    builder.setUInt16(4, 0, 0);
    return Field_slot_Builder(builder);
  }

  /// A group.
  Field_group_Builder initGroup() {
    builder.setUInt16(4, 1, 0);
    return Field_group_Builder(builder);
  }

  Field_union_Builder get which {
    return switch (builder.getUInt16(4, 0)) {
      0 => Field_slot_Builder(builder),
      1 => Field_group_Builder(builder),
      _ => Field_notInSchema_Builder(builder),
    };
  }
}

sealed class Field_union_Builder<R extends Field_union_Reader>
    extends $capnproto.CapnpStructBuilder<R> {
  const Field_union_Builder(super.builder);
}

// group Field.ordinal

class Field_ordinal_Reader extends $capnproto.CapnpStructReader {
  const Field_ordinal_Reader(super.reader);

  static const typeId = -4931206560496546842;

  Field_ordinal_union_Reader get which {
    return switch (reader.getUInt16(5, 0)) {
      0 => Field_ordinal_implicit_Reader(reader),
      1 => Field_ordinal_explicit_Reader(reader),
      _ => Field_ordinal_notInSchema_Reader(reader),
    };
  }
}

sealed class Field_ordinal_union_Reader extends $capnproto.CapnpStructReader {
  const Field_ordinal_union_Reader(super.reader);
}

class Field_ordinal_Builder
    extends $capnproto.CapnpStructBuilder<Field_ordinal_Reader> {
  const Field_ordinal_Builder(super.builder);

  Field_ordinal_Builder.initPointer($capnproto.PointerBuilder builder)
      : this(builder.initStruct(structSize));

  Field_ordinal_Builder.getFromPointer(
    $capnproto.PointerBuilder builder,
    $typed_data.ByteData defaultValue,
  ) : this(builder.getStruct(structSize, defaultValue).unwrap());

  static const structSize =
      $capnproto.StructSize(dataWords: 3, pointerCount: 4);

  @$core.override
  Field_ordinal_Reader get asReader => Field_ordinal_Reader(builder.asReader);

  void setImplicit() {
    builder.setUInt16(5, 0, 0);
  }

  /// The original ordinal number given to the field.  You probably should NOT use this; if you need
  /// a numeric identifier for a field, use its position within the field array for its scope.
  /// The ordinal is given here mainly just so that the original schema text can be reproduced given
  /// the compiled version -- i.e. so that `capnp compile -ocapnp` can do its job.
  set explicit($core.int value) {
    builder.setUInt16(5, 1, 0);
    return builder.setUInt16(6, value, 0);
  }

  Field_ordinal_union_Builder get which {
    return switch (builder.getUInt16(5, 0)) {
      0 => Field_ordinal_implicit_Builder(builder),
      1 => Field_ordinal_explicit_Builder(builder),
      _ => Field_ordinal_notInSchema_Builder(builder),
    };
  }
}

sealed class Field_ordinal_union_Builder<R extends Field_ordinal_union_Reader>
    extends $capnproto.CapnpStructBuilder<R> {
  const Field_ordinal_union_Builder(super.builder);
}

class Field_ordinal_implicit_Reader extends Field_ordinal_union_Reader {
  const Field_ordinal_implicit_Reader(super.reader);

  void get value {}
}

class Field_ordinal_implicit_Builder extends Field_ordinal_union_Builder {
  const Field_ordinal_implicit_Builder(super.builder);

  @$core.override
  Field_ordinal_implicit_Reader get asReader =>
      Field_ordinal_implicit_Reader(builder.asReader);

  void get value {}
}

/// The original ordinal number given to the field.  You probably should NOT use this; if you need
/// a numeric identifier for a field, use its position within the field array for its scope.
/// The ordinal is given here mainly just so that the original schema text can be reproduced given
/// the compiled version -- i.e. so that `capnp compile -ocapnp` can do its job.
class Field_ordinal_explicit_Reader extends Field_ordinal_union_Reader {
  const Field_ordinal_explicit_Reader(super.reader);

  $core.int get value => reader.getUInt16(6, 0);
}

/// The original ordinal number given to the field.  You probably should NOT use this; if you need
/// a numeric identifier for a field, use its position within the field array for its scope.
/// The ordinal is given here mainly just so that the original schema text can be reproduced given
/// the compiled version -- i.e. so that `capnp compile -ocapnp` can do its job.
class Field_ordinal_explicit_Builder extends Field_ordinal_union_Builder {
  const Field_ordinal_explicit_Builder(super.builder);

  @$core.override
  Field_ordinal_explicit_Reader get asReader =>
      Field_ordinal_explicit_Reader(builder.asReader);

  $core.int get value {
    return builder.getUInt16(6, 0);
  }

  set value($core.int value) {
    return builder.setUInt16(6, value, 0);
  }
}

class Field_ordinal_notInSchema_Reader extends Field_ordinal_union_Reader {
  const Field_ordinal_notInSchema_Reader(super.reader);
}

class Field_ordinal_notInSchema_Builder extends Field_ordinal_union_Builder {
  const Field_ordinal_notInSchema_Builder(super.reader);

  @$core.override
  Field_ordinal_notInSchema_Reader get asReader =>
      Field_ordinal_notInSchema_Reader(builder.asReader);
}

// group Field.slot

/// A regular, non-group, non-fixed-list field.
class Field_slot_Reader extends Field_union_Reader {
  const Field_slot_Reader(super.reader);

  static const typeId = -4313598213782997905;

  /// Offset, in units of the field's size, from the beginning of the section in which the field
  /// resides.  E.g. for a UInt32 field, multiply this by 4 to get the byte offset from the
  /// beginning of the data section.
  $core.int get offset => reader.getUInt32(1, 0);

  $core.bool get hasType_ => !reader.getPointer(2).isNull;
  Type_Reader get type =>
      Type_Reader(reader.getPointer(2).getStruct(null).unwrap());

  $core.bool get hasDefaultValue => !reader.getPointer(3).isNull;
  Value_Reader get defaultValue =>
      Value_Reader(reader.getPointer(3).getStruct(null).unwrap());

  /// Whether the default value was specified explicitly.  Non-explicit default values are always
  /// zero or empty values.  Usually, whether the default value was explicit shouldn't matter.
  /// The main use case for this flag is for structs representing method parameters:
  /// explicitly-defaulted parameters may be allowed to be omitted when calling the method.
  $core.bool get hadExplicitDefault => reader.getBool(128, false);
}

/// A regular, non-group, non-fixed-list field.
class Field_slot_Builder extends Field_union_Builder<Field_slot_Reader> {
  const Field_slot_Builder(super.builder);

  Field_slot_Builder.initPointer($capnproto.PointerBuilder builder)
      : this(builder.initStruct(structSize));

  Field_slot_Builder.getFromPointer(
    $capnproto.PointerBuilder builder,
    $typed_data.ByteData defaultValue,
  ) : this(builder.getStruct(structSize, defaultValue).unwrap());

  static const structSize =
      $capnproto.StructSize(dataWords: 3, pointerCount: 4);

  @$core.override
  Field_slot_Reader get asReader => Field_slot_Reader(builder.asReader);

  /// Offset, in units of the field's size, from the beginning of the section in which the field
  /// resides.  E.g. for a UInt32 field, multiply this by 4 to get the byte offset from the
  /// beginning of the data section.
  $core.int get offset {
    return builder.getUInt32(1, 0);
  }

  set offset($core.int value) {
    return builder.setUInt32(1, value, 0);
  }

  $core.bool get hasType_ => !builder.getPointer(2).isNull;
  Type_Builder getType_() {
    return Type_Builder(
      builder.getPointer(2).getStruct(Type_Builder.structSize, null).unwrap(),
    );
  }

  Type_Builder initType_() {
    return Type_Builder(
      builder.getPointer(2).initStruct(Type_Builder.structSize),
    );
  }

  $core.bool get hasDefaultValue => !builder.getPointer(3).isNull;
  Value_Builder getDefaultValue() {
    return Value_Builder(
      builder.getPointer(3).getStruct(Value_Builder.structSize, null).unwrap(),
    );
  }

  Value_Builder initDefaultValue() {
    return Value_Builder(
      builder.getPointer(3).initStruct(Value_Builder.structSize),
    );
  }

  /// Whether the default value was specified explicitly.  Non-explicit default values are always
  /// zero or empty values.  Usually, whether the default value was explicit shouldn't matter.
  /// The main use case for this flag is for structs representing method parameters:
  /// explicitly-defaulted parameters may be allowed to be omitted when calling the method.
  $core.bool get hadExplicitDefault {
    return builder.getBool(128, false);
  }

  set hadExplicitDefault($core.bool value) {
    return builder.setBool(128, value, false);
  }
}

// group Field.group

/// A group.
class Field_group_Reader extends Field_union_Reader {
  const Field_group_Reader(super.reader);

  static const typeId = -3819952041676301039;

  /// The ID of the group's node.
  $core.int get typeId_ => reader.getUInt64(2, 0);
}

/// A group.
class Field_group_Builder extends Field_union_Builder<Field_group_Reader> {
  const Field_group_Builder(super.builder);

  Field_group_Builder.initPointer($capnproto.PointerBuilder builder)
      : this(builder.initStruct(structSize));

  Field_group_Builder.getFromPointer(
    $capnproto.PointerBuilder builder,
    $typed_data.ByteData defaultValue,
  ) : this(builder.getStruct(structSize, defaultValue).unwrap());

  static const structSize =
      $capnproto.StructSize(dataWords: 3, pointerCount: 4);

  @$core.override
  Field_group_Reader get asReader => Field_group_Reader(builder.asReader);

  /// The ID of the group's node.
  $core.int get typeId_ {
    return builder.getUInt64(2, 0);
  }

  set typeId_($core.int value) {
    return builder.setUInt64(2, value, 0);
  }
}

class Field_notInSchema_Reader extends Field_union_Reader {
  const Field_notInSchema_Reader(super.reader);
}

class Field_notInSchema_Builder extends Field_union_Builder {
  const Field_notInSchema_Builder(super.reader);

  @$core.override
  Field_notInSchema_Reader get asReader =>
      Field_notInSchema_Reader(builder.asReader);
}

// struct Enumerant

/// Schema for member of an enum.
class Enumerant_Reader extends $capnproto.CapnpStructReader {
  const Enumerant_Reader(super.reader);

  static const typeId = -7527066474740671923;

  $core.bool get hasName => !reader.getPointer(0).isNull;
  $core.String get name => reader.getPointer(0).getText(null).unwrap();

  /// Specifies order in which the enumerants were declared in the code.
  /// Like Struct.Field.codeOrder.
  $core.int get codeOrder => reader.getUInt16(0, 0);

  $core.bool get hasAnnotations => !reader.getPointer(1).isNull;
  $capnproto.StructListReader<Annotation_Reader> get annotations {
    return $capnproto.StructListReader.getFromPointer(
      reader.getPointer(1),
      Annotation_Reader.new,
      null,
    ).unwrap();
  }
}

/// Schema for member of an enum.
class Enumerant_Builder
    extends $capnproto.CapnpStructBuilder<Enumerant_Reader> {
  const Enumerant_Builder(super.builder);

  Enumerant_Builder.initPointer($capnproto.PointerBuilder builder)
      : this(builder.initStruct(structSize));

  Enumerant_Builder.getFromPointer(
    $capnproto.PointerBuilder builder,
    $typed_data.ByteData defaultValue,
  ) : this(builder.getStruct(structSize, defaultValue).unwrap());

  static const structSize =
      $capnproto.StructSize(dataWords: 1, pointerCount: 2);

  @$core.override
  Enumerant_Reader get asReader => Enumerant_Reader(builder.asReader);

  $core.bool get hasName => !builder.getPointer(0).isNull;
  $core.String get name => builder.getPointer(0).getText(null).unwrap();
  set name($core.String value) {
    builder.getPointer(0).setText(value);
  }

  /// Specifies order in which the enumerants were declared in the code.
  /// Like Struct.Field.codeOrder.
  $core.int get codeOrder {
    return builder.getUInt16(0, 0);
  }

  set codeOrder($core.int value) {
    return builder.setUInt16(0, value, 0);
  }

  $core.bool get hasAnnotations => !builder.getPointer(1).isNull;
  $capnproto.StructListBuilder<Annotation_Builder, Annotation_Reader>
      get annotations {
    return $capnproto.StructListBuilder.getFromPointer(
      builder.getPointer(1),
      Annotation_Builder.structSize,
      Annotation_Builder.new,
      Annotation_Reader.new,
      null,
    ).unwrap();
  }

  $capnproto.StructListBuilder<Annotation_Builder, Annotation_Reader>
      initAnnotations($core.int length) {
    return $capnproto.StructListBuilder.initPointer(
      builder.getPointer(1),
      length,
      Annotation_Builder.structSize,
      Annotation_Builder.new,
      Annotation_Reader.new,
    );
  }
}

// struct Superclass

class Superclass_Reader extends $capnproto.CapnpStructReader {
  const Superclass_Reader(super.reader);

  static const typeId = -6226742573199468552;

  $core.int get id => reader.getUInt64(0, 0);

  $core.bool get hasBrand => !reader.getPointer(0).isNull;
  Brand_Reader get brand =>
      Brand_Reader(reader.getPointer(0).getStruct(null).unwrap());
}

class Superclass_Builder
    extends $capnproto.CapnpStructBuilder<Superclass_Reader> {
  const Superclass_Builder(super.builder);

  Superclass_Builder.initPointer($capnproto.PointerBuilder builder)
      : this(builder.initStruct(structSize));

  Superclass_Builder.getFromPointer(
    $capnproto.PointerBuilder builder,
    $typed_data.ByteData defaultValue,
  ) : this(builder.getStruct(structSize, defaultValue).unwrap());

  static const structSize =
      $capnproto.StructSize(dataWords: 1, pointerCount: 1);

  @$core.override
  Superclass_Reader get asReader => Superclass_Reader(builder.asReader);

  $core.int get id {
    return builder.getUInt64(0, 0);
  }

  set id($core.int value) {
    return builder.setUInt64(0, value, 0);
  }

  $core.bool get hasBrand => !builder.getPointer(0).isNull;
  Brand_Builder getBrand() {
    return Brand_Builder(
      builder.getPointer(0).getStruct(Brand_Builder.structSize, null).unwrap(),
    );
  }

  Brand_Builder initBrand() {
    return Brand_Builder(
      builder.getPointer(0).initStruct(Brand_Builder.structSize),
    );
  }
}

// struct Method

/// Schema for method of an interface.
class Method_Reader extends $capnproto.CapnpStructReader {
  const Method_Reader(super.reader);

  static const typeId = -7709937290030396032;

  $core.bool get hasName => !reader.getPointer(0).isNull;
  $core.String get name => reader.getPointer(0).getText(null).unwrap();

  /// Specifies order in which the methods were declared in the code.
  /// Like Struct.Field.codeOrder.
  $core.int get codeOrder => reader.getUInt16(0, 0);

  /// ID of the parameter struct type.  If a named parameter list was specified in the method
  /// declaration (rather than a single struct parameter type) then a corresponding struct type is
  /// auto-generated.  Such an auto-generated type will not be listed in the interface's
  /// `nestedNodes` and its `scopeId` will be zero -- it is completely detached from the namespace.
  /// (Awkwardly, it does of course inherit generic parameters from the method's scope, which makes
  /// this a situation where you can't just climb the scope chain to find where a particular
  /// generic parameter was introduced. Making the `scopeId` zero was a mistake.)
  $core.int get paramStructType => reader.getUInt64(1, 0);

  /// ID of the return struct type; similar to `paramStructType`.
  $core.int get resultStructType => reader.getUInt64(2, 0);

  $core.bool get hasAnnotations => !reader.getPointer(1).isNull;
  $capnproto.StructListReader<Annotation_Reader> get annotations {
    return $capnproto.StructListReader.getFromPointer(
      reader.getPointer(1),
      Annotation_Reader.new,
      null,
    ).unwrap();
  }

  $core.bool get hasParamBrand => !reader.getPointer(2).isNull;

  /// Brand of param struct type.
  Brand_Reader get paramBrand =>
      Brand_Reader(reader.getPointer(2).getStruct(null).unwrap());

  $core.bool get hasResultBrand => !reader.getPointer(3).isNull;

  /// Brand of result struct type.
  Brand_Reader get resultBrand =>
      Brand_Reader(reader.getPointer(3).getStruct(null).unwrap());

  $core.bool get hasImplicitParameters => !reader.getPointer(4).isNull;

  /// The parameters listed in [] (typically, type / generic parameters), whose bindings are intended
  /// to be inferred rather than specified explicitly, although not all languages support this.
  $capnproto.StructListReader<Node_Parameter_Reader> get implicitParameters {
    return $capnproto.StructListReader.getFromPointer(
      reader.getPointer(4),
      Node_Parameter_Reader.new,
      null,
    ).unwrap();
  }
}

/// Schema for method of an interface.
class Method_Builder extends $capnproto.CapnpStructBuilder<Method_Reader> {
  const Method_Builder(super.builder);

  Method_Builder.initPointer($capnproto.PointerBuilder builder)
      : this(builder.initStruct(structSize));

  Method_Builder.getFromPointer(
    $capnproto.PointerBuilder builder,
    $typed_data.ByteData defaultValue,
  ) : this(builder.getStruct(structSize, defaultValue).unwrap());

  static const structSize =
      $capnproto.StructSize(dataWords: 3, pointerCount: 5);

  @$core.override
  Method_Reader get asReader => Method_Reader(builder.asReader);

  $core.bool get hasName => !builder.getPointer(0).isNull;
  $core.String get name => builder.getPointer(0).getText(null).unwrap();
  set name($core.String value) {
    builder.getPointer(0).setText(value);
  }

  /// Specifies order in which the methods were declared in the code.
  /// Like Struct.Field.codeOrder.
  $core.int get codeOrder {
    return builder.getUInt16(0, 0);
  }

  set codeOrder($core.int value) {
    return builder.setUInt16(0, value, 0);
  }

  /// ID of the parameter struct type.  If a named parameter list was specified in the method
  /// declaration (rather than a single struct parameter type) then a corresponding struct type is
  /// auto-generated.  Such an auto-generated type will not be listed in the interface's
  /// `nestedNodes` and its `scopeId` will be zero -- it is completely detached from the namespace.
  /// (Awkwardly, it does of course inherit generic parameters from the method's scope, which makes
  /// this a situation where you can't just climb the scope chain to find where a particular
  /// generic parameter was introduced. Making the `scopeId` zero was a mistake.)
  $core.int get paramStructType {
    return builder.getUInt64(1, 0);
  }

  set paramStructType($core.int value) {
    return builder.setUInt64(1, value, 0);
  }

  /// ID of the return struct type; similar to `paramStructType`.
  $core.int get resultStructType {
    return builder.getUInt64(2, 0);
  }

  set resultStructType($core.int value) {
    return builder.setUInt64(2, value, 0);
  }

  $core.bool get hasAnnotations => !builder.getPointer(1).isNull;
  $capnproto.StructListBuilder<Annotation_Builder, Annotation_Reader>
      get annotations {
    return $capnproto.StructListBuilder.getFromPointer(
      builder.getPointer(1),
      Annotation_Builder.structSize,
      Annotation_Builder.new,
      Annotation_Reader.new,
      null,
    ).unwrap();
  }

  $capnproto.StructListBuilder<Annotation_Builder, Annotation_Reader>
      initAnnotations($core.int length) {
    return $capnproto.StructListBuilder.initPointer(
      builder.getPointer(1),
      length,
      Annotation_Builder.structSize,
      Annotation_Builder.new,
      Annotation_Reader.new,
    );
  }

  $core.bool get hasParamBrand => !builder.getPointer(2).isNull;

  /// Brand of param struct type.
  Brand_Builder getParamBrand() {
    return Brand_Builder(
      builder.getPointer(2).getStruct(Brand_Builder.structSize, null).unwrap(),
    );
  }

  Brand_Builder initParamBrand() {
    return Brand_Builder(
      builder.getPointer(2).initStruct(Brand_Builder.structSize),
    );
  }

  $core.bool get hasResultBrand => !builder.getPointer(3).isNull;

  /// Brand of result struct type.
  Brand_Builder getResultBrand() {
    return Brand_Builder(
      builder.getPointer(3).getStruct(Brand_Builder.structSize, null).unwrap(),
    );
  }

  Brand_Builder initResultBrand() {
    return Brand_Builder(
      builder.getPointer(3).initStruct(Brand_Builder.structSize),
    );
  }

  $core.bool get hasImplicitParameters => !builder.getPointer(4).isNull;

  /// The parameters listed in [] (typically, type / generic parameters), whose bindings are intended
  /// to be inferred rather than specified explicitly, although not all languages support this.
  $capnproto.StructListBuilder<Node_Parameter_Builder, Node_Parameter_Reader>
      get implicitParameters {
    return $capnproto.StructListBuilder.getFromPointer(
      builder.getPointer(4),
      Node_Parameter_Builder.structSize,
      Node_Parameter_Builder.new,
      Node_Parameter_Reader.new,
      null,
    ).unwrap();
  }

  $capnproto.StructListBuilder<Node_Parameter_Builder, Node_Parameter_Reader>
      initImplicitParameters($core.int length) {
    return $capnproto.StructListBuilder.initPointer(
      builder.getPointer(4),
      length,
      Node_Parameter_Builder.structSize,
      Node_Parameter_Builder.new,
      Node_Parameter_Reader.new,
    );
  }
}

// struct Type

/// Represents a type expression.
class Type_Reader extends $capnproto.CapnpStructReader {
  const Type_Reader(super.reader);

  static const typeId = -3426261928404988832;

  Type_union_Reader get which {
    return switch (reader.getUInt16(0, 0)) {
      0 => Type_void_Reader(reader),
      1 => Type_bool_Reader(reader),
      2 => Type_int8_Reader(reader),
      3 => Type_int16_Reader(reader),
      4 => Type_int32_Reader(reader),
      5 => Type_int64_Reader(reader),
      6 => Type_uint8_Reader(reader),
      7 => Type_uint16_Reader(reader),
      8 => Type_uint32_Reader(reader),
      9 => Type_uint64_Reader(reader),
      10 => Type_float32_Reader(reader),
      11 => Type_float64_Reader(reader),
      12 => Type_text_Reader(reader),
      13 => Type_data_Reader(reader),
      14 => Type_list_Reader(reader),
      15 => Type_enum_Reader(reader),
      16 => Type_struct_Reader(reader),
      17 => Type_interface_Reader(reader),
      18 => Type_anyPointer_Reader(reader),
      _ => Type_notInSchema_Reader(reader),
    };
  }
}

sealed class Type_union_Reader extends $capnproto.CapnpStructReader {
  const Type_union_Reader(super.reader);
}

/// Represents a type expression.
class Type_Builder extends $capnproto.CapnpStructBuilder<Type_Reader> {
  const Type_Builder(super.builder);

  Type_Builder.initPointer($capnproto.PointerBuilder builder)
      : this(builder.initStruct(structSize));

  Type_Builder.getFromPointer(
    $capnproto.PointerBuilder builder,
    $typed_data.ByteData defaultValue,
  ) : this(builder.getStruct(structSize, defaultValue).unwrap());

  static const structSize =
      $capnproto.StructSize(dataWords: 3, pointerCount: 1);

  @$core.override
  Type_Reader get asReader => Type_Reader(builder.asReader);

  void setVoid_() {
    builder.setUInt16(0, 0, 0);
  }

  void setBool() {
    builder.setUInt16(0, 1, 0);
  }

  void setInt8() {
    builder.setUInt16(0, 2, 0);
  }

  void setInt16() {
    builder.setUInt16(0, 3, 0);
  }

  void setInt32() {
    builder.setUInt16(0, 4, 0);
  }

  void setInt64() {
    builder.setUInt16(0, 5, 0);
  }

  void setUint8() {
    builder.setUInt16(0, 6, 0);
  }

  void setUint16() {
    builder.setUInt16(0, 7, 0);
  }

  void setUint32() {
    builder.setUInt16(0, 8, 0);
  }

  void setUint64() {
    builder.setUInt16(0, 9, 0);
  }

  void setFloat32() {
    builder.setUInt16(0, 10, 0);
  }

  void setFloat64() {
    builder.setUInt16(0, 11, 0);
  }

  void setText() {
    builder.setUInt16(0, 12, 0);
  }

  void setData() {
    builder.setUInt16(0, 13, 0);
  }

  Type_list_Builder initList() {
    builder.setUInt16(0, 14, 0);
    return Type_list_Builder(builder);
  }

  Type_enum_Builder initEnum() {
    builder.setUInt16(0, 15, 0);
    return Type_enum_Builder(builder);
  }

  Type_struct_Builder initStruct() {
    builder.setUInt16(0, 16, 0);
    return Type_struct_Builder(builder);
  }

  Type_interface_Builder initInterface() {
    builder.setUInt16(0, 17, 0);
    return Type_interface_Builder(builder);
  }

  Type_anyPointer_Builder initAnyPointer() {
    builder.setUInt16(0, 18, 0);
    return Type_anyPointer_Builder(builder);
  }

  Type_union_Builder get which {
    return switch (builder.getUInt16(0, 0)) {
      0 => Type_void_Builder(builder),
      1 => Type_bool_Builder(builder),
      2 => Type_int8_Builder(builder),
      3 => Type_int16_Builder(builder),
      4 => Type_int32_Builder(builder),
      5 => Type_int64_Builder(builder),
      6 => Type_uint8_Builder(builder),
      7 => Type_uint16_Builder(builder),
      8 => Type_uint32_Builder(builder),
      9 => Type_uint64_Builder(builder),
      10 => Type_float32_Builder(builder),
      11 => Type_float64_Builder(builder),
      12 => Type_text_Builder(builder),
      13 => Type_data_Builder(builder),
      14 => Type_list_Builder(builder),
      15 => Type_enum_Builder(builder),
      16 => Type_struct_Builder(builder),
      17 => Type_interface_Builder(builder),
      18 => Type_anyPointer_Builder(builder),
      _ => Type_notInSchema_Builder(builder),
    };
  }
}

sealed class Type_union_Builder<R extends Type_union_Reader>
    extends $capnproto.CapnpStructBuilder<R> {
  const Type_union_Builder(super.builder);
}

class Type_void_Reader extends Type_union_Reader {
  const Type_void_Reader(super.reader);

  void get value {}
}

class Type_void_Builder extends Type_union_Builder {
  const Type_void_Builder(super.builder);

  @$core.override
  Type_void_Reader get asReader => Type_void_Reader(builder.asReader);

  void get value {}
}

class Type_bool_Reader extends Type_union_Reader {
  const Type_bool_Reader(super.reader);

  void get value {}
}

class Type_bool_Builder extends Type_union_Builder {
  const Type_bool_Builder(super.builder);

  @$core.override
  Type_bool_Reader get asReader => Type_bool_Reader(builder.asReader);

  void get value {}
}

class Type_int8_Reader extends Type_union_Reader {
  const Type_int8_Reader(super.reader);

  void get value {}
}

class Type_int8_Builder extends Type_union_Builder {
  const Type_int8_Builder(super.builder);

  @$core.override
  Type_int8_Reader get asReader => Type_int8_Reader(builder.asReader);

  void get value {}
}

class Type_int16_Reader extends Type_union_Reader {
  const Type_int16_Reader(super.reader);

  void get value {}
}

class Type_int16_Builder extends Type_union_Builder {
  const Type_int16_Builder(super.builder);

  @$core.override
  Type_int16_Reader get asReader => Type_int16_Reader(builder.asReader);

  void get value {}
}

class Type_int32_Reader extends Type_union_Reader {
  const Type_int32_Reader(super.reader);

  void get value {}
}

class Type_int32_Builder extends Type_union_Builder {
  const Type_int32_Builder(super.builder);

  @$core.override
  Type_int32_Reader get asReader => Type_int32_Reader(builder.asReader);

  void get value {}
}

class Type_int64_Reader extends Type_union_Reader {
  const Type_int64_Reader(super.reader);

  void get value {}
}

class Type_int64_Builder extends Type_union_Builder {
  const Type_int64_Builder(super.builder);

  @$core.override
  Type_int64_Reader get asReader => Type_int64_Reader(builder.asReader);

  void get value {}
}

class Type_uint8_Reader extends Type_union_Reader {
  const Type_uint8_Reader(super.reader);

  void get value {}
}

class Type_uint8_Builder extends Type_union_Builder {
  const Type_uint8_Builder(super.builder);

  @$core.override
  Type_uint8_Reader get asReader => Type_uint8_Reader(builder.asReader);

  void get value {}
}

class Type_uint16_Reader extends Type_union_Reader {
  const Type_uint16_Reader(super.reader);

  void get value {}
}

class Type_uint16_Builder extends Type_union_Builder {
  const Type_uint16_Builder(super.builder);

  @$core.override
  Type_uint16_Reader get asReader => Type_uint16_Reader(builder.asReader);

  void get value {}
}

class Type_uint32_Reader extends Type_union_Reader {
  const Type_uint32_Reader(super.reader);

  void get value {}
}

class Type_uint32_Builder extends Type_union_Builder {
  const Type_uint32_Builder(super.builder);

  @$core.override
  Type_uint32_Reader get asReader => Type_uint32_Reader(builder.asReader);

  void get value {}
}

class Type_uint64_Reader extends Type_union_Reader {
  const Type_uint64_Reader(super.reader);

  void get value {}
}

class Type_uint64_Builder extends Type_union_Builder {
  const Type_uint64_Builder(super.builder);

  @$core.override
  Type_uint64_Reader get asReader => Type_uint64_Reader(builder.asReader);

  void get value {}
}

class Type_float32_Reader extends Type_union_Reader {
  const Type_float32_Reader(super.reader);

  void get value {}
}

class Type_float32_Builder extends Type_union_Builder {
  const Type_float32_Builder(super.builder);

  @$core.override
  Type_float32_Reader get asReader => Type_float32_Reader(builder.asReader);

  void get value {}
}

class Type_float64_Reader extends Type_union_Reader {
  const Type_float64_Reader(super.reader);

  void get value {}
}

class Type_float64_Builder extends Type_union_Builder {
  const Type_float64_Builder(super.builder);

  @$core.override
  Type_float64_Reader get asReader => Type_float64_Reader(builder.asReader);

  void get value {}
}

class Type_text_Reader extends Type_union_Reader {
  const Type_text_Reader(super.reader);

  void get value {}
}

class Type_text_Builder extends Type_union_Builder {
  const Type_text_Builder(super.builder);

  @$core.override
  Type_text_Reader get asReader => Type_text_Reader(builder.asReader);

  void get value {}
}

class Type_data_Reader extends Type_union_Reader {
  const Type_data_Reader(super.reader);

  void get value {}
}

class Type_data_Builder extends Type_union_Builder {
  const Type_data_Builder(super.builder);

  @$core.override
  Type_data_Reader get asReader => Type_data_Reader(builder.asReader);

  void get value {}
}

// group Type.list

class Type_list_Reader extends Type_union_Reader {
  const Type_list_Reader(super.reader);

  static const typeId = -8653885327718421865;

  $core.bool get hasElementType => !reader.getPointer(0).isNull;
  Type_Reader get elementType =>
      Type_Reader(reader.getPointer(0).getStruct(null).unwrap());
}

class Type_list_Builder extends Type_union_Builder<Type_list_Reader> {
  const Type_list_Builder(super.builder);

  Type_list_Builder.initPointer($capnproto.PointerBuilder builder)
      : this(builder.initStruct(structSize));

  Type_list_Builder.getFromPointer(
    $capnproto.PointerBuilder builder,
    $typed_data.ByteData defaultValue,
  ) : this(builder.getStruct(structSize, defaultValue).unwrap());

  static const structSize =
      $capnproto.StructSize(dataWords: 3, pointerCount: 1);

  @$core.override
  Type_list_Reader get asReader => Type_list_Reader(builder.asReader);

  $core.bool get hasElementType => !builder.getPointer(0).isNull;
  Type_Builder getElementType() {
    return Type_Builder(
      builder.getPointer(0).getStruct(Type_Builder.structSize, null).unwrap(),
    );
  }

  Type_Builder initElementType() {
    return Type_Builder(
      builder.getPointer(0).initStruct(Type_Builder.structSize),
    );
  }
}

// group Type.enum

class Type_enum_Reader extends Type_union_Reader {
  const Type_enum_Reader(super.reader);

  static const typeId = -7057571138871785559;

  $core.int get typeId_ => reader.getUInt64(1, 0);

  $core.bool get hasBrand => !reader.getPointer(0).isNull;
  Brand_Reader get brand =>
      Brand_Reader(reader.getPointer(0).getStruct(null).unwrap());
}

class Type_enum_Builder extends Type_union_Builder<Type_enum_Reader> {
  const Type_enum_Builder(super.builder);

  Type_enum_Builder.initPointer($capnproto.PointerBuilder builder)
      : this(builder.initStruct(structSize));

  Type_enum_Builder.getFromPointer(
    $capnproto.PointerBuilder builder,
    $typed_data.ByteData defaultValue,
  ) : this(builder.getStruct(structSize, defaultValue).unwrap());

  static const structSize =
      $capnproto.StructSize(dataWords: 3, pointerCount: 1);

  @$core.override
  Type_enum_Reader get asReader => Type_enum_Reader(builder.asReader);

  $core.int get typeId_ {
    return builder.getUInt64(1, 0);
  }

  set typeId_($core.int value) {
    return builder.setUInt64(1, value, 0);
  }

  $core.bool get hasBrand => !builder.getPointer(0).isNull;
  Brand_Builder getBrand() {
    return Brand_Builder(
      builder.getPointer(0).getStruct(Brand_Builder.structSize, null).unwrap(),
    );
  }

  Brand_Builder initBrand() {
    return Brand_Builder(
      builder.getPointer(0).initStruct(Brand_Builder.structSize),
    );
  }
}

// group Type.struct

class Type_struct_Reader extends Type_union_Reader {
  const Type_struct_Reader(super.reader);

  static const typeId = -6036389888414398765;

  $core.int get typeId_ => reader.getUInt64(1, 0);

  $core.bool get hasBrand => !reader.getPointer(0).isNull;
  Brand_Reader get brand =>
      Brand_Reader(reader.getPointer(0).getStruct(null).unwrap());
}

class Type_struct_Builder extends Type_union_Builder<Type_struct_Reader> {
  const Type_struct_Builder(super.builder);

  Type_struct_Builder.initPointer($capnproto.PointerBuilder builder)
      : this(builder.initStruct(structSize));

  Type_struct_Builder.getFromPointer(
    $capnproto.PointerBuilder builder,
    $typed_data.ByteData defaultValue,
  ) : this(builder.getStruct(structSize, defaultValue).unwrap());

  static const structSize =
      $capnproto.StructSize(dataWords: 3, pointerCount: 1);

  @$core.override
  Type_struct_Reader get asReader => Type_struct_Reader(builder.asReader);

  $core.int get typeId_ {
    return builder.getUInt64(1, 0);
  }

  set typeId_($core.int value) {
    return builder.setUInt64(1, value, 0);
  }

  $core.bool get hasBrand => !builder.getPointer(0).isNull;
  Brand_Builder getBrand() {
    return Brand_Builder(
      builder.getPointer(0).getStruct(Brand_Builder.structSize, null).unwrap(),
    );
  }

  Brand_Builder initBrand() {
    return Brand_Builder(
      builder.getPointer(0).initStruct(Brand_Builder.structSize),
    );
  }
}

// group Type.interface

class Type_interface_Reader extends Type_union_Reader {
  const Type_interface_Reader(super.reader);

  static const typeId = -1329746708477047617;

  $core.int get typeId_ => reader.getUInt64(1, 0);

  $core.bool get hasBrand => !reader.getPointer(0).isNull;
  Brand_Reader get brand =>
      Brand_Reader(reader.getPointer(0).getStruct(null).unwrap());
}

class Type_interface_Builder extends Type_union_Builder<Type_interface_Reader> {
  const Type_interface_Builder(super.builder);

  Type_interface_Builder.initPointer($capnproto.PointerBuilder builder)
      : this(builder.initStruct(structSize));

  Type_interface_Builder.getFromPointer(
    $capnproto.PointerBuilder builder,
    $typed_data.ByteData defaultValue,
  ) : this(builder.getStruct(structSize, defaultValue).unwrap());

  static const structSize =
      $capnproto.StructSize(dataWords: 3, pointerCount: 1);

  @$core.override
  Type_interface_Reader get asReader => Type_interface_Reader(builder.asReader);

  $core.int get typeId_ {
    return builder.getUInt64(1, 0);
  }

  set typeId_($core.int value) {
    return builder.setUInt64(1, value, 0);
  }

  $core.bool get hasBrand => !builder.getPointer(0).isNull;
  Brand_Builder getBrand() {
    return Brand_Builder(
      builder.getPointer(0).getStruct(Brand_Builder.structSize, null).unwrap(),
    );
  }

  Brand_Builder initBrand() {
    return Brand_Builder(
      builder.getPointer(0).initStruct(Brand_Builder.structSize),
    );
  }
}

// group Type.anyPointer

class Type_anyPointer_Reader extends Type_union_Reader {
  const Type_anyPointer_Reader(super.reader);

  static const typeId = -4443012238990751247;

  Type_anyPointer_union_Reader get which {
    return switch (reader.getUInt16(4, 0)) {
      0 => Type_anyPointer_unconstrained_Reader(reader),
      1 => Type_anyPointer_parameter_Reader(reader),
      2 => Type_anyPointer_implicitMethodParameter_Reader(reader),
      _ => Type_anyPointer_notInSchema_Reader(reader),
    };
  }
}

sealed class Type_anyPointer_union_Reader extends $capnproto.CapnpStructReader {
  const Type_anyPointer_union_Reader(super.reader);
}

class Type_anyPointer_Builder
    extends Type_union_Builder<Type_anyPointer_Reader> {
  const Type_anyPointer_Builder(super.builder);

  Type_anyPointer_Builder.initPointer($capnproto.PointerBuilder builder)
      : this(builder.initStruct(structSize));

  Type_anyPointer_Builder.getFromPointer(
    $capnproto.PointerBuilder builder,
    $typed_data.ByteData defaultValue,
  ) : this(builder.getStruct(structSize, defaultValue).unwrap());

  static const structSize =
      $capnproto.StructSize(dataWords: 3, pointerCount: 1);

  @$core.override
  Type_anyPointer_Reader get asReader =>
      Type_anyPointer_Reader(builder.asReader);

  /// A regular AnyPointer.
  ///
  /// The name "unconstrained" means as opposed to constraining it to match a type parameter.
  /// In retrospect this name is probably a poor choice given that it may still be constrained
  /// to be a struct, list, or capability.
  Type_anyPointer_unconstrained_Builder initUnconstrained() {
    builder.setUInt16(4, 0, 0);
    return Type_anyPointer_unconstrained_Builder(builder);
  }

  /// This is actually a reference to a type parameter defined within this scope.
  Type_anyPointer_parameter_Builder initParameter() {
    builder.setUInt16(4, 1, 0);
    return Type_anyPointer_parameter_Builder(builder);
  }

  /// This is actually a reference to an implicit (generic) parameter of a method. The only
  /// legal context for this type to appear is inside Method.paramBrand or Method.resultBrand.
  Type_anyPointer_implicitMethodParameter_Builder
      initImplicitMethodParameter() {
    builder.setUInt16(4, 2, 0);
    return Type_anyPointer_implicitMethodParameter_Builder(builder);
  }

  Type_anyPointer_union_Builder get which {
    return switch (builder.getUInt16(4, 0)) {
      0 => Type_anyPointer_unconstrained_Builder(builder),
      1 => Type_anyPointer_parameter_Builder(builder),
      2 => Type_anyPointer_implicitMethodParameter_Builder(builder),
      _ => Type_anyPointer_notInSchema_Builder(builder),
    };
  }
}

sealed class Type_anyPointer_union_Builder<
        R extends Type_anyPointer_union_Reader>
    extends $capnproto.CapnpStructBuilder<R> {
  const Type_anyPointer_union_Builder(super.builder);
}

// group Type.anyPointer.unconstrained

/// A regular AnyPointer.
///
/// The name "unconstrained" means as opposed to constraining it to match a type parameter.
/// In retrospect this name is probably a poor choice given that it may still be constrained
/// to be a struct, list, or capability.
class Type_anyPointer_unconstrained_Reader
    extends Type_anyPointer_union_Reader {
  const Type_anyPointer_unconstrained_Reader(super.reader);

  static const typeId = -8197853719134914986;

  Type_anyPointer_unconstrained_union_Reader get which {
    return switch (reader.getUInt16(5, 0)) {
      0 => Type_anyPointer_unconstrained_anyKind_Reader(reader),
      1 => Type_anyPointer_unconstrained_struct_Reader(reader),
      2 => Type_anyPointer_unconstrained_list_Reader(reader),
      3 => Type_anyPointer_unconstrained_capability_Reader(reader),
      _ => Type_anyPointer_unconstrained_notInSchema_Reader(reader),
    };
  }
}

sealed class Type_anyPointer_unconstrained_union_Reader
    extends $capnproto.CapnpStructReader {
  const Type_anyPointer_unconstrained_union_Reader(super.reader);
}

/// A regular AnyPointer.
///
/// The name "unconstrained" means as opposed to constraining it to match a type parameter.
/// In retrospect this name is probably a poor choice given that it may still be constrained
/// to be a struct, list, or capability.
class Type_anyPointer_unconstrained_Builder
    extends Type_anyPointer_union_Builder<
        Type_anyPointer_unconstrained_Reader> {
  const Type_anyPointer_unconstrained_Builder(super.builder);

  Type_anyPointer_unconstrained_Builder.initPointer(
    $capnproto.PointerBuilder builder,
  ) : this(builder.initStruct(structSize));

  Type_anyPointer_unconstrained_Builder.getFromPointer(
    $capnproto.PointerBuilder builder,
    $typed_data.ByteData defaultValue,
  ) : this(builder.getStruct(structSize, defaultValue).unwrap());

  static const structSize =
      $capnproto.StructSize(dataWords: 3, pointerCount: 1);

  @$core.override
  Type_anyPointer_unconstrained_Reader get asReader =>
      Type_anyPointer_unconstrained_Reader(builder.asReader);

  /// truly AnyPointer
  void setAnyKind() {
    builder.setUInt16(5, 0, 0);
  }

  /// AnyStruct
  void setStruct() {
    builder.setUInt16(5, 1, 0);
  }

  /// AnyList
  void setList() {
    builder.setUInt16(5, 2, 0);
  }

  /// Capability
  void setCapability() {
    builder.setUInt16(5, 3, 0);
  }

  Type_anyPointer_unconstrained_union_Builder get which {
    return switch (builder.getUInt16(5, 0)) {
      0 => Type_anyPointer_unconstrained_anyKind_Builder(builder),
      1 => Type_anyPointer_unconstrained_struct_Builder(builder),
      2 => Type_anyPointer_unconstrained_list_Builder(builder),
      3 => Type_anyPointer_unconstrained_capability_Builder(builder),
      _ => Type_anyPointer_unconstrained_notInSchema_Builder(builder),
    };
  }
}

sealed class Type_anyPointer_unconstrained_union_Builder<
        R extends Type_anyPointer_unconstrained_union_Reader>
    extends $capnproto.CapnpStructBuilder<R> {
  const Type_anyPointer_unconstrained_union_Builder(super.builder);
}

/// truly AnyPointer
class Type_anyPointer_unconstrained_anyKind_Reader
    extends Type_anyPointer_unconstrained_union_Reader {
  const Type_anyPointer_unconstrained_anyKind_Reader(super.reader);

  void get value {}
}

/// truly AnyPointer
class Type_anyPointer_unconstrained_anyKind_Builder
    extends Type_anyPointer_unconstrained_union_Builder {
  const Type_anyPointer_unconstrained_anyKind_Builder(super.builder);

  @$core.override
  Type_anyPointer_unconstrained_anyKind_Reader get asReader =>
      Type_anyPointer_unconstrained_anyKind_Reader(builder.asReader);

  void get value {}
}

/// AnyStruct
class Type_anyPointer_unconstrained_struct_Reader
    extends Type_anyPointer_unconstrained_union_Reader {
  const Type_anyPointer_unconstrained_struct_Reader(super.reader);

  void get value {}
}

/// AnyStruct
class Type_anyPointer_unconstrained_struct_Builder
    extends Type_anyPointer_unconstrained_union_Builder {
  const Type_anyPointer_unconstrained_struct_Builder(super.builder);

  @$core.override
  Type_anyPointer_unconstrained_struct_Reader get asReader =>
      Type_anyPointer_unconstrained_struct_Reader(builder.asReader);

  void get value {}
}

/// AnyList
class Type_anyPointer_unconstrained_list_Reader
    extends Type_anyPointer_unconstrained_union_Reader {
  const Type_anyPointer_unconstrained_list_Reader(super.reader);

  void get value {}
}

/// AnyList
class Type_anyPointer_unconstrained_list_Builder
    extends Type_anyPointer_unconstrained_union_Builder {
  const Type_anyPointer_unconstrained_list_Builder(super.builder);

  @$core.override
  Type_anyPointer_unconstrained_list_Reader get asReader =>
      Type_anyPointer_unconstrained_list_Reader(builder.asReader);

  void get value {}
}

/// Capability
class Type_anyPointer_unconstrained_capability_Reader
    extends Type_anyPointer_unconstrained_union_Reader {
  const Type_anyPointer_unconstrained_capability_Reader(super.reader);

  void get value {}
}

/// Capability
class Type_anyPointer_unconstrained_capability_Builder
    extends Type_anyPointer_unconstrained_union_Builder {
  const Type_anyPointer_unconstrained_capability_Builder(super.builder);

  @$core.override
  Type_anyPointer_unconstrained_capability_Reader get asReader =>
      Type_anyPointer_unconstrained_capability_Reader(builder.asReader);

  void get value {}
}

class Type_anyPointer_unconstrained_notInSchema_Reader
    extends Type_anyPointer_unconstrained_union_Reader {
  const Type_anyPointer_unconstrained_notInSchema_Reader(super.reader);
}

class Type_anyPointer_unconstrained_notInSchema_Builder
    extends Type_anyPointer_unconstrained_union_Builder {
  const Type_anyPointer_unconstrained_notInSchema_Builder(super.reader);

  @$core.override
  Type_anyPointer_unconstrained_notInSchema_Reader get asReader =>
      Type_anyPointer_unconstrained_notInSchema_Reader(builder.asReader);
}

// group Type.anyPointer.parameter

/// This is actually a reference to a type parameter defined within this scope.
class Type_anyPointer_parameter_Reader extends Type_anyPointer_union_Reader {
  const Type_anyPointer_parameter_Reader(super.reader);

  static const typeId = -7074601801531438459;

  /// ID of the generic type whose parameter we're referencing. This should be a parent of the
  /// current scope.
  $core.int get scopeId => reader.getUInt64(2, 0);

  /// Index of the parameter within the generic type's parameter list.
  $core.int get parameterIndex => reader.getUInt16(5, 0);
}

/// This is actually a reference to a type parameter defined within this scope.
class Type_anyPointer_parameter_Builder
    extends Type_anyPointer_union_Builder<Type_anyPointer_parameter_Reader> {
  const Type_anyPointer_parameter_Builder(super.builder);

  Type_anyPointer_parameter_Builder.initPointer(
    $capnproto.PointerBuilder builder,
  ) : this(builder.initStruct(structSize));

  Type_anyPointer_parameter_Builder.getFromPointer(
    $capnproto.PointerBuilder builder,
    $typed_data.ByteData defaultValue,
  ) : this(builder.getStruct(structSize, defaultValue).unwrap());

  static const structSize =
      $capnproto.StructSize(dataWords: 3, pointerCount: 1);

  @$core.override
  Type_anyPointer_parameter_Reader get asReader =>
      Type_anyPointer_parameter_Reader(builder.asReader);

  /// ID of the generic type whose parameter we're referencing. This should be a parent of the
  /// current scope.
  $core.int get scopeId {
    return builder.getUInt64(2, 0);
  }

  set scopeId($core.int value) {
    return builder.setUInt64(2, value, 0);
  }

  /// Index of the parameter within the generic type's parameter list.
  $core.int get parameterIndex {
    return builder.getUInt16(5, 0);
  }

  set parameterIndex($core.int value) {
    return builder.setUInt16(5, value, 0);
  }
}

// group Type.anyPointer.implicitMethodParameter

/// This is actually a reference to an implicit (generic) parameter of a method. The only
/// legal context for this type to appear is inside Method.paramBrand or Method.resultBrand.
class Type_anyPointer_implicitMethodParameter_Reader
    extends Type_anyPointer_union_Reader {
  const Type_anyPointer_implicitMethodParameter_Reader(super.reader);

  static const typeId = -4976537983867493772;

  $core.int get parameterIndex => reader.getUInt16(5, 0);
}

/// This is actually a reference to an implicit (generic) parameter of a method. The only
/// legal context for this type to appear is inside Method.paramBrand or Method.resultBrand.
class Type_anyPointer_implicitMethodParameter_Builder
    extends Type_anyPointer_union_Builder<
        Type_anyPointer_implicitMethodParameter_Reader> {
  const Type_anyPointer_implicitMethodParameter_Builder(super.builder);

  Type_anyPointer_implicitMethodParameter_Builder.initPointer(
    $capnproto.PointerBuilder builder,
  ) : this(builder.initStruct(structSize));

  Type_anyPointer_implicitMethodParameter_Builder.getFromPointer(
    $capnproto.PointerBuilder builder,
    $typed_data.ByteData defaultValue,
  ) : this(builder.getStruct(structSize, defaultValue).unwrap());

  static const structSize =
      $capnproto.StructSize(dataWords: 3, pointerCount: 1);

  @$core.override
  Type_anyPointer_implicitMethodParameter_Reader get asReader =>
      Type_anyPointer_implicitMethodParameter_Reader(builder.asReader);

  $core.int get parameterIndex {
    return builder.getUInt16(5, 0);
  }

  set parameterIndex($core.int value) {
    return builder.setUInt16(5, value, 0);
  }
}

class Type_anyPointer_notInSchema_Reader extends Type_anyPointer_union_Reader {
  const Type_anyPointer_notInSchema_Reader(super.reader);
}

class Type_anyPointer_notInSchema_Builder
    extends Type_anyPointer_union_Builder {
  const Type_anyPointer_notInSchema_Builder(super.reader);

  @$core.override
  Type_anyPointer_notInSchema_Reader get asReader =>
      Type_anyPointer_notInSchema_Reader(builder.asReader);
}

class Type_notInSchema_Reader extends Type_union_Reader {
  const Type_notInSchema_Reader(super.reader);
}

class Type_notInSchema_Builder extends Type_union_Builder {
  const Type_notInSchema_Builder(super.reader);

  @$core.override
  Type_notInSchema_Reader get asReader =>
      Type_notInSchema_Reader(builder.asReader);
}

// struct Brand

/// Specifies bindings for parameters of generics. Since these bindings turn a generic into a
/// non-generic, we call it the "brand".
class Brand_Reader extends $capnproto.CapnpStructReader {
  const Brand_Reader(super.reader);

  static const typeId = -8055719342561213909;

  $core.bool get hasScopes => !reader.getPointer(0).isNull;

  /// For each of the target type and each of its parent scopes, a parameterization may be included
  /// in this list. If no parameterization is included for a particular relevant scope, then either
  /// that scope has no parameters or all parameters should be considered to be `AnyPointer`.
  $capnproto.StructListReader<Brand_Scope_Reader> get scopes {
    return $capnproto.StructListReader.getFromPointer(
      reader.getPointer(0),
      Brand_Scope_Reader.new,
      null,
    ).unwrap();
  }
}

/// Specifies bindings for parameters of generics. Since these bindings turn a generic into a
/// non-generic, we call it the "brand".
class Brand_Builder extends $capnproto.CapnpStructBuilder<Brand_Reader> {
  const Brand_Builder(super.builder);

  Brand_Builder.initPointer($capnproto.PointerBuilder builder)
      : this(builder.initStruct(structSize));

  Brand_Builder.getFromPointer(
    $capnproto.PointerBuilder builder,
    $typed_data.ByteData defaultValue,
  ) : this(builder.getStruct(structSize, defaultValue).unwrap());

  static const structSize =
      $capnproto.StructSize(dataWords: 0, pointerCount: 1);

  @$core.override
  Brand_Reader get asReader => Brand_Reader(builder.asReader);

  $core.bool get hasScopes => !builder.getPointer(0).isNull;

  /// For each of the target type and each of its parent scopes, a parameterization may be included
  /// in this list. If no parameterization is included for a particular relevant scope, then either
  /// that scope has no parameters or all parameters should be considered to be `AnyPointer`.
  $capnproto.StructListBuilder<Brand_Scope_Builder, Brand_Scope_Reader>
      get scopes {
    return $capnproto.StructListBuilder.getFromPointer(
      builder.getPointer(0),
      Brand_Scope_Builder.structSize,
      Brand_Scope_Builder.new,
      Brand_Scope_Reader.new,
      null,
    ).unwrap();
  }

  $capnproto.StructListBuilder<Brand_Scope_Builder, Brand_Scope_Reader>
      initScopes($core.int length) {
    return $capnproto.StructListBuilder.initPointer(
      builder.getPointer(0),
      length,
      Brand_Scope_Builder.structSize,
      Brand_Scope_Builder.new,
      Brand_Scope_Reader.new,
    );
  }
}

// struct Brand.Scope

class Brand_Scope_Reader extends $capnproto.CapnpStructReader {
  const Brand_Scope_Reader(super.reader);

  static const typeId = -6064320624553923639;

  /// ID of the scope to which these params apply.
  $core.int get scopeId => reader.getUInt64(0, 0);

  Brand_Scope_union_Reader get which {
    return switch (reader.getUInt16(4, 0)) {
      0 => Brand_Scope_bind_Reader(reader),
      1 => Brand_Scope_inherit_Reader(reader),
      _ => Brand_Scope_notInSchema_Reader(reader),
    };
  }
}

sealed class Brand_Scope_union_Reader extends $capnproto.CapnpStructReader {
  const Brand_Scope_union_Reader(super.reader);
}

class Brand_Scope_Builder
    extends $capnproto.CapnpStructBuilder<Brand_Scope_Reader> {
  const Brand_Scope_Builder(super.builder);

  Brand_Scope_Builder.initPointer($capnproto.PointerBuilder builder)
      : this(builder.initStruct(structSize));

  Brand_Scope_Builder.getFromPointer(
    $capnproto.PointerBuilder builder,
    $typed_data.ByteData defaultValue,
  ) : this(builder.getStruct(structSize, defaultValue).unwrap());

  static const structSize =
      $capnproto.StructSize(dataWords: 2, pointerCount: 1);

  @$core.override
  Brand_Scope_Reader get asReader => Brand_Scope_Reader(builder.asReader);

  /// ID of the scope to which these params apply.
  $core.int get scopeId {
    return builder.getUInt64(0, 0);
  }

  set scopeId($core.int value) {
    return builder.setUInt64(0, value, 0);
  }

  $core.bool get hasBind =>
      builder.getUInt16(4, 0) == 0 && !builder.getPointer(0).isNull;

  /// List of parameter bindings.
  $capnproto.StructListBuilder<Brand_Binding_Builder, Brand_Binding_Reader>
      initBind($core.int length) {
    builder.setUInt16(4, 0, 0);
    return $capnproto.StructListBuilder.initPointer(
      builder.getPointer(0),
      length,
      Brand_Binding_Builder.structSize,
      Brand_Binding_Builder.new,
      Brand_Binding_Reader.new,
    );
  }

  /// The place where the Brand appears is within this scope or a sub-scope, and bindings
  /// for this scope are deferred to later Brand applications. This is equivalent to a
  /// pass-through binding list, where each of this scope's parameters is bound to itself.
  /// For example:
  ///
  ///   struct Outer(T) {
  ///     struct Inner {
  ///       value @0 :T;
  ///     }
  ///     innerInherit @0 :Inner;            # Outer Brand.Scope is `inherit`.
  ///     innerBindSelf @1 :Outer(T).Inner;  # Outer Brand.Scope explicitly binds T to T.
  ///   }
  ///
  /// The innerInherit and innerBindSelf fields have equivalent types, but different Brand
  /// styles.
  void setInherit() {
    builder.setUInt16(4, 1, 0);
  }

  Brand_Scope_union_Builder get which {
    return switch (builder.getUInt16(4, 0)) {
      0 => Brand_Scope_bind_Builder(builder),
      1 => Brand_Scope_inherit_Builder(builder),
      _ => Brand_Scope_notInSchema_Builder(builder),
    };
  }
}

sealed class Brand_Scope_union_Builder<R extends Brand_Scope_union_Reader>
    extends $capnproto.CapnpStructBuilder<R> {
  const Brand_Scope_union_Builder(super.builder);
}

/// List of parameter bindings.
class Brand_Scope_bind_Reader extends Brand_Scope_union_Reader {
  const Brand_Scope_bind_Reader(super.reader);

  $core.bool get hasValue => !reader.getPointer(0).isNull;
  $capnproto.StructListReader<Brand_Binding_Reader> get value {
    return $capnproto.StructListReader.getFromPointer(
      reader.getPointer(0),
      Brand_Binding_Reader.new,
      null,
    ).unwrap();
  }
}

/// List of parameter bindings.
class Brand_Scope_bind_Builder extends Brand_Scope_union_Builder {
  const Brand_Scope_bind_Builder(super.builder);

  @$core.override
  Brand_Scope_bind_Reader get asReader =>
      Brand_Scope_bind_Reader(builder.asReader);

  $core.bool get hasValue => !builder.getPointer(0).isNull;
  $capnproto.StructListBuilder<Brand_Binding_Builder, Brand_Binding_Reader>
      get value {
    return $capnproto.StructListBuilder.getFromPointer(
      builder.getPointer(0),
      Brand_Binding_Builder.structSize,
      Brand_Binding_Builder.new,
      Brand_Binding_Reader.new,
      null,
    ).unwrap();
  }

  $capnproto.StructListBuilder<Brand_Binding_Builder, Brand_Binding_Reader>
      initValue($core.int length) {
    return $capnproto.StructListBuilder.initPointer(
      builder.getPointer(0),
      length,
      Brand_Binding_Builder.structSize,
      Brand_Binding_Builder.new,
      Brand_Binding_Reader.new,
    );
  }
}

/// The place where the Brand appears is within this scope or a sub-scope, and bindings
/// for this scope are deferred to later Brand applications. This is equivalent to a
/// pass-through binding list, where each of this scope's parameters is bound to itself.
/// For example:
///
///   struct Outer(T) {
///     struct Inner {
///       value @0 :T;
///     }
///     innerInherit @0 :Inner;            # Outer Brand.Scope is `inherit`.
///     innerBindSelf @1 :Outer(T).Inner;  # Outer Brand.Scope explicitly binds T to T.
///   }
///
/// The innerInherit and innerBindSelf fields have equivalent types, but different Brand
/// styles.
class Brand_Scope_inherit_Reader extends Brand_Scope_union_Reader {
  const Brand_Scope_inherit_Reader(super.reader);

  void get value {}
}

/// The place where the Brand appears is within this scope or a sub-scope, and bindings
/// for this scope are deferred to later Brand applications. This is equivalent to a
/// pass-through binding list, where each of this scope's parameters is bound to itself.
/// For example:
///
///   struct Outer(T) {
///     struct Inner {
///       value @0 :T;
///     }
///     innerInherit @0 :Inner;            # Outer Brand.Scope is `inherit`.
///     innerBindSelf @1 :Outer(T).Inner;  # Outer Brand.Scope explicitly binds T to T.
///   }
///
/// The innerInherit and innerBindSelf fields have equivalent types, but different Brand
/// styles.
class Brand_Scope_inherit_Builder extends Brand_Scope_union_Builder {
  const Brand_Scope_inherit_Builder(super.builder);

  @$core.override
  Brand_Scope_inherit_Reader get asReader =>
      Brand_Scope_inherit_Reader(builder.asReader);

  void get value {}
}

class Brand_Scope_notInSchema_Reader extends Brand_Scope_union_Reader {
  const Brand_Scope_notInSchema_Reader(super.reader);
}

class Brand_Scope_notInSchema_Builder extends Brand_Scope_union_Builder {
  const Brand_Scope_notInSchema_Builder(super.reader);

  @$core.override
  Brand_Scope_notInSchema_Reader get asReader =>
      Brand_Scope_notInSchema_Reader(builder.asReader);
}

// struct Brand.Binding

class Brand_Binding_Reader extends $capnproto.CapnpStructReader {
  const Brand_Binding_Reader(super.reader);

  static const typeId = -4007133746529638404;

  Brand_Binding_union_Reader get which {
    return switch (reader.getUInt16(0, 0)) {
      0 => Brand_Binding_unbound_Reader(reader),
      1 => Brand_Binding_type_Reader(reader),
      _ => Brand_Binding_notInSchema_Reader(reader),
    };
  }
}

sealed class Brand_Binding_union_Reader extends $capnproto.CapnpStructReader {
  const Brand_Binding_union_Reader(super.reader);
}

class Brand_Binding_Builder
    extends $capnproto.CapnpStructBuilder<Brand_Binding_Reader> {
  const Brand_Binding_Builder(super.builder);

  Brand_Binding_Builder.initPointer($capnproto.PointerBuilder builder)
      : this(builder.initStruct(structSize));

  Brand_Binding_Builder.getFromPointer(
    $capnproto.PointerBuilder builder,
    $typed_data.ByteData defaultValue,
  ) : this(builder.getStruct(structSize, defaultValue).unwrap());

  static const structSize =
      $capnproto.StructSize(dataWords: 1, pointerCount: 1);

  @$core.override
  Brand_Binding_Reader get asReader => Brand_Binding_Reader(builder.asReader);

  void setUnbound() {
    builder.setUInt16(0, 0, 0);
  }

  $core.bool get hasType_ =>
      builder.getUInt16(0, 0) == 1 && !builder.getPointer(0).isNull;
  Type_Builder initType_() {
    builder.setUInt16(0, 1, 0);
    return Type_Builder(
      builder.getPointer(0).initStruct(Type_Builder.structSize),
    );
  }

  Brand_Binding_union_Builder get which {
    return switch (builder.getUInt16(0, 0)) {
      0 => Brand_Binding_unbound_Builder(builder),
      1 => Brand_Binding_type_Builder(builder),
      _ => Brand_Binding_notInSchema_Builder(builder),
    };
  }
}

sealed class Brand_Binding_union_Builder<R extends Brand_Binding_union_Reader>
    extends $capnproto.CapnpStructBuilder<R> {
  const Brand_Binding_union_Builder(super.builder);
}

class Brand_Binding_unbound_Reader extends Brand_Binding_union_Reader {
  const Brand_Binding_unbound_Reader(super.reader);

  void get value {}
}

class Brand_Binding_unbound_Builder extends Brand_Binding_union_Builder {
  const Brand_Binding_unbound_Builder(super.builder);

  @$core.override
  Brand_Binding_unbound_Reader get asReader =>
      Brand_Binding_unbound_Reader(builder.asReader);

  void get value {}
}

class Brand_Binding_type_Reader extends Brand_Binding_union_Reader {
  const Brand_Binding_type_Reader(super.reader);

  $core.bool get hasValue => !reader.getPointer(0).isNull;
  Type_Reader get value =>
      Type_Reader(reader.getPointer(0).getStruct(null).unwrap());
}

class Brand_Binding_type_Builder extends Brand_Binding_union_Builder {
  const Brand_Binding_type_Builder(super.builder);

  @$core.override
  Brand_Binding_type_Reader get asReader =>
      Brand_Binding_type_Reader(builder.asReader);

  $core.bool get hasValue => !builder.getPointer(0).isNull;
  Type_Builder getValue() {
    return Type_Builder(
      builder.getPointer(0).getStruct(Type_Builder.structSize, null).unwrap(),
    );
  }

  Type_Builder initValue() {
    return Type_Builder(
      builder.getPointer(0).initStruct(Type_Builder.structSize),
    );
  }
}

class Brand_Binding_notInSchema_Reader extends Brand_Binding_union_Reader {
  const Brand_Binding_notInSchema_Reader(super.reader);
}

class Brand_Binding_notInSchema_Builder extends Brand_Binding_union_Builder {
  const Brand_Binding_notInSchema_Builder(super.reader);

  @$core.override
  Brand_Binding_notInSchema_Reader get asReader =>
      Brand_Binding_notInSchema_Reader(builder.asReader);
}

// struct Value

/// Represents a value, e.g. a field default value, constant value, or annotation value.
class Value_Reader extends $capnproto.CapnpStructReader {
  const Value_Reader(super.reader);

  static const typeId = -3592785279591641957;

  Value_union_Reader get which {
    return switch (reader.getUInt16(0, 0)) {
      0 => Value_void_Reader(reader),
      1 => Value_bool_Reader(reader),
      2 => Value_int8_Reader(reader),
      3 => Value_int16_Reader(reader),
      4 => Value_int32_Reader(reader),
      5 => Value_int64_Reader(reader),
      6 => Value_uint8_Reader(reader),
      7 => Value_uint16_Reader(reader),
      8 => Value_uint32_Reader(reader),
      9 => Value_uint64_Reader(reader),
      10 => Value_float32_Reader(reader),
      11 => Value_float64_Reader(reader),
      12 => Value_text_Reader(reader),
      13 => Value_data_Reader(reader),
      14 => Value_list_Reader(reader),
      15 => Value_enum_Reader(reader),
      16 => Value_struct_Reader(reader),
      17 => Value_interface_Reader(reader),
      18 => Value_anyPointer_Reader(reader),
      _ => Value_notInSchema_Reader(reader),
    };
  }
}

sealed class Value_union_Reader extends $capnproto.CapnpStructReader {
  const Value_union_Reader(super.reader);
}

/// Represents a value, e.g. a field default value, constant value, or annotation value.
class Value_Builder extends $capnproto.CapnpStructBuilder<Value_Reader> {
  const Value_Builder(super.builder);

  Value_Builder.initPointer($capnproto.PointerBuilder builder)
      : this(builder.initStruct(structSize));

  Value_Builder.getFromPointer(
    $capnproto.PointerBuilder builder,
    $typed_data.ByteData defaultValue,
  ) : this(builder.getStruct(structSize, defaultValue).unwrap());

  static const structSize =
      $capnproto.StructSize(dataWords: 2, pointerCount: 1);

  @$core.override
  Value_Reader get asReader => Value_Reader(builder.asReader);

  void setVoid_() {
    builder.setUInt16(0, 0, 0);
  }

  set bool($core.bool value) {
    builder.setUInt16(0, 1, 0);
    return builder.setBool(16, value, false);
  }

  set int8($core.int value) {
    builder.setUInt16(0, 2, 0);
    return builder.setInt8(2, value, 0);
  }

  set int16($core.int value) {
    builder.setUInt16(0, 3, 0);
    return builder.setInt16(1, value, 0);
  }

  set int32($core.int value) {
    builder.setUInt16(0, 4, 0);
    return builder.setInt32(1, value, 0);
  }

  set int64($core.int value) {
    builder.setUInt16(0, 5, 0);
    return builder.setInt64(1, value, 0);
  }

  set uint8($core.int value) {
    builder.setUInt16(0, 6, 0);
    return builder.setUInt8(2, value, 0);
  }

  set uint16($core.int value) {
    builder.setUInt16(0, 7, 0);
    return builder.setUInt16(1, value, 0);
  }

  set uint32($core.int value) {
    builder.setUInt16(0, 8, 0);
    return builder.setUInt32(1, value, 0);
  }

  set uint64($core.int value) {
    builder.setUInt16(0, 9, 0);
    return builder.setUInt64(1, value, 0);
  }

  set float32($core.double value) {
    builder.setUInt16(0, 10, 0);
    return builder.setFloat32(1, value, 0);
  }

  set float64($core.double value) {
    builder.setUInt16(0, 11, 0);
    return builder.setFloat64(1, value, 0);
  }

  $core.bool get hasText =>
      builder.getUInt16(0, 0) == 12 && !builder.getPointer(0).isNull;
  set text($core.String value) {
    builder.setUInt16(0, 12, 0);
    builder.getPointer(0).setText(value);
  }

  $core.bool get hasData =>
      builder.getUInt16(0, 0) == 13 && !builder.getPointer(0).isNull;
  set data($typed_data.ByteData value) {
    builder.setUInt16(0, 13, 0);
    builder.getPointer(0).setData(value);
  }

  $core.bool get hasList =>
      builder.getUInt16(0, 0) == 14 && !builder.getPointer(0).isNull;
  $capnproto.AnyPointerBuilder initList() {
    builder.setUInt16(0, 14, 0);
    final result = $capnproto.AnyPointerBuilder(builder.getPointer(0));
    result.clear();
    return result;
  }

  set enum_($core.int value) {
    builder.setUInt16(0, 15, 0);
    return builder.setUInt16(1, value, 0);
  }

  $core.bool get hasStruct =>
      builder.getUInt16(0, 0) == 16 && !builder.getPointer(0).isNull;
  $capnproto.AnyPointerBuilder initStruct() {
    builder.setUInt16(0, 16, 0);
    final result = $capnproto.AnyPointerBuilder(builder.getPointer(0));
    result.clear();
    return result;
  }

  /// The only interface value that can be represented statically is "null", whose methods always
  /// throw exceptions.
  void setInterface_() {
    builder.setUInt16(0, 17, 0);
  }

  $core.bool get hasAnyPointer =>
      builder.getUInt16(0, 0) == 18 && !builder.getPointer(0).isNull;
  $capnproto.AnyPointerBuilder initAnyPointer() {
    builder.setUInt16(0, 18, 0);
    final result = $capnproto.AnyPointerBuilder(builder.getPointer(0));
    result.clear();
    return result;
  }

  Value_union_Builder get which {
    return switch (builder.getUInt16(0, 0)) {
      0 => Value_void_Builder(builder),
      1 => Value_bool_Builder(builder),
      2 => Value_int8_Builder(builder),
      3 => Value_int16_Builder(builder),
      4 => Value_int32_Builder(builder),
      5 => Value_int64_Builder(builder),
      6 => Value_uint8_Builder(builder),
      7 => Value_uint16_Builder(builder),
      8 => Value_uint32_Builder(builder),
      9 => Value_uint64_Builder(builder),
      10 => Value_float32_Builder(builder),
      11 => Value_float64_Builder(builder),
      12 => Value_text_Builder(builder),
      13 => Value_data_Builder(builder),
      14 => Value_list_Builder(builder),
      15 => Value_enum_Builder(builder),
      16 => Value_struct_Builder(builder),
      17 => Value_interface_Builder(builder),
      18 => Value_anyPointer_Builder(builder),
      _ => Value_notInSchema_Builder(builder),
    };
  }
}

sealed class Value_union_Builder<R extends Value_union_Reader>
    extends $capnproto.CapnpStructBuilder<R> {
  const Value_union_Builder(super.builder);
}

class Value_void_Reader extends Value_union_Reader {
  const Value_void_Reader(super.reader);

  void get value {}
}

class Value_void_Builder extends Value_union_Builder {
  const Value_void_Builder(super.builder);

  @$core.override
  Value_void_Reader get asReader => Value_void_Reader(builder.asReader);

  void get value {}
}

class Value_bool_Reader extends Value_union_Reader {
  const Value_bool_Reader(super.reader);

  $core.bool get value => reader.getBool(16, false);
}

class Value_bool_Builder extends Value_union_Builder {
  const Value_bool_Builder(super.builder);

  @$core.override
  Value_bool_Reader get asReader => Value_bool_Reader(builder.asReader);

  $core.bool get value {
    return builder.getBool(16, false);
  }

  set value($core.bool value) {
    return builder.setBool(16, value, false);
  }
}

class Value_int8_Reader extends Value_union_Reader {
  const Value_int8_Reader(super.reader);

  $core.int get value => reader.getInt8(2, 0);
}

class Value_int8_Builder extends Value_union_Builder {
  const Value_int8_Builder(super.builder);

  @$core.override
  Value_int8_Reader get asReader => Value_int8_Reader(builder.asReader);

  $core.int get value {
    return builder.getInt8(2, 0);
  }

  set value($core.int value) {
    return builder.setInt8(2, value, 0);
  }
}

class Value_int16_Reader extends Value_union_Reader {
  const Value_int16_Reader(super.reader);

  $core.int get value => reader.getInt16(1, 0);
}

class Value_int16_Builder extends Value_union_Builder {
  const Value_int16_Builder(super.builder);

  @$core.override
  Value_int16_Reader get asReader => Value_int16_Reader(builder.asReader);

  $core.int get value {
    return builder.getInt16(1, 0);
  }

  set value($core.int value) {
    return builder.setInt16(1, value, 0);
  }
}

class Value_int32_Reader extends Value_union_Reader {
  const Value_int32_Reader(super.reader);

  $core.int get value => reader.getInt32(1, 0);
}

class Value_int32_Builder extends Value_union_Builder {
  const Value_int32_Builder(super.builder);

  @$core.override
  Value_int32_Reader get asReader => Value_int32_Reader(builder.asReader);

  $core.int get value {
    return builder.getInt32(1, 0);
  }

  set value($core.int value) {
    return builder.setInt32(1, value, 0);
  }
}

class Value_int64_Reader extends Value_union_Reader {
  const Value_int64_Reader(super.reader);

  $core.int get value => reader.getInt64(1, 0);
}

class Value_int64_Builder extends Value_union_Builder {
  const Value_int64_Builder(super.builder);

  @$core.override
  Value_int64_Reader get asReader => Value_int64_Reader(builder.asReader);

  $core.int get value {
    return builder.getInt64(1, 0);
  }

  set value($core.int value) {
    return builder.setInt64(1, value, 0);
  }
}

class Value_uint8_Reader extends Value_union_Reader {
  const Value_uint8_Reader(super.reader);

  $core.int get value => reader.getUInt8(2, 0);
}

class Value_uint8_Builder extends Value_union_Builder {
  const Value_uint8_Builder(super.builder);

  @$core.override
  Value_uint8_Reader get asReader => Value_uint8_Reader(builder.asReader);

  $core.int get value {
    return builder.getUInt8(2, 0);
  }

  set value($core.int value) {
    return builder.setUInt8(2, value, 0);
  }
}

class Value_uint16_Reader extends Value_union_Reader {
  const Value_uint16_Reader(super.reader);

  $core.int get value => reader.getUInt16(1, 0);
}

class Value_uint16_Builder extends Value_union_Builder {
  const Value_uint16_Builder(super.builder);

  @$core.override
  Value_uint16_Reader get asReader => Value_uint16_Reader(builder.asReader);

  $core.int get value {
    return builder.getUInt16(1, 0);
  }

  set value($core.int value) {
    return builder.setUInt16(1, value, 0);
  }
}

class Value_uint32_Reader extends Value_union_Reader {
  const Value_uint32_Reader(super.reader);

  $core.int get value => reader.getUInt32(1, 0);
}

class Value_uint32_Builder extends Value_union_Builder {
  const Value_uint32_Builder(super.builder);

  @$core.override
  Value_uint32_Reader get asReader => Value_uint32_Reader(builder.asReader);

  $core.int get value {
    return builder.getUInt32(1, 0);
  }

  set value($core.int value) {
    return builder.setUInt32(1, value, 0);
  }
}

class Value_uint64_Reader extends Value_union_Reader {
  const Value_uint64_Reader(super.reader);

  $core.int get value => reader.getUInt64(1, 0);
}

class Value_uint64_Builder extends Value_union_Builder {
  const Value_uint64_Builder(super.builder);

  @$core.override
  Value_uint64_Reader get asReader => Value_uint64_Reader(builder.asReader);

  $core.int get value {
    return builder.getUInt64(1, 0);
  }

  set value($core.int value) {
    return builder.setUInt64(1, value, 0);
  }
}

class Value_float32_Reader extends Value_union_Reader {
  const Value_float32_Reader(super.reader);

  $core.double get value => reader.getFloat32(1, 0);
}

class Value_float32_Builder extends Value_union_Builder {
  const Value_float32_Builder(super.builder);

  @$core.override
  Value_float32_Reader get asReader => Value_float32_Reader(builder.asReader);

  $core.double get value {
    return builder.getFloat32(1, 0);
  }

  set value($core.double value) {
    return builder.setFloat32(1, value, 0);
  }
}

class Value_float64_Reader extends Value_union_Reader {
  const Value_float64_Reader(super.reader);

  $core.double get value => reader.getFloat64(1, 0);
}

class Value_float64_Builder extends Value_union_Builder {
  const Value_float64_Builder(super.builder);

  @$core.override
  Value_float64_Reader get asReader => Value_float64_Reader(builder.asReader);

  $core.double get value {
    return builder.getFloat64(1, 0);
  }

  set value($core.double value) {
    return builder.setFloat64(1, value, 0);
  }
}

class Value_text_Reader extends Value_union_Reader {
  const Value_text_Reader(super.reader);

  $core.bool get hasValue => !reader.getPointer(0).isNull;
  $core.String get value => reader.getPointer(0).getText(null).unwrap();
}

class Value_text_Builder extends Value_union_Builder {
  const Value_text_Builder(super.builder);

  @$core.override
  Value_text_Reader get asReader => Value_text_Reader(builder.asReader);

  $core.bool get hasValue => !builder.getPointer(0).isNull;
  $core.String get value => builder.getPointer(0).getText(null).unwrap();
  set value($core.String value) {
    builder.getPointer(0).setText(value);
  }
}

class Value_data_Reader extends Value_union_Reader {
  const Value_data_Reader(super.reader);

  $core.bool get hasValue => !reader.getPointer(0).isNull;
  $typed_data.ByteData get value => reader.getPointer(0).getData(null).unwrap();
}

class Value_data_Builder extends Value_union_Builder {
  const Value_data_Builder(super.builder);

  @$core.override
  Value_data_Reader get asReader => Value_data_Reader(builder.asReader);

  $core.bool get hasValue => !builder.getPointer(0).isNull;
  $typed_data.ByteData get value =>
      builder.getPointer(0).getData(null).unwrap();
  set value($typed_data.ByteData value) {
    builder.getPointer(0).setData(value);
  }
}

class Value_list_Reader extends Value_union_Reader {
  const Value_list_Reader(super.reader);

  $core.bool get hasValue => !reader.getPointer(0).isNull;
  $capnproto.AnyPointerReader get value =>
      $capnproto.AnyPointerReader(reader.getPointer(0));
}

class Value_list_Builder extends Value_union_Builder {
  const Value_list_Builder(super.builder);

  @$core.override
  Value_list_Reader get asReader => Value_list_Reader(builder.asReader);

  $core.bool get hasValue => !builder.getPointer(0).isNull;
  $capnproto.AnyPointerBuilder initValue() {
    final result = $capnproto.AnyPointerBuilder(builder.getPointer(0));
    result.clear();
    return result;
  }
}

class Value_enum_Reader extends Value_union_Reader {
  const Value_enum_Reader(super.reader);

  $core.int get value => reader.getUInt16(1, 0);
}

class Value_enum_Builder extends Value_union_Builder {
  const Value_enum_Builder(super.builder);

  @$core.override
  Value_enum_Reader get asReader => Value_enum_Reader(builder.asReader);

  $core.int get value {
    return builder.getUInt16(1, 0);
  }

  set value($core.int value) {
    return builder.setUInt16(1, value, 0);
  }
}

class Value_struct_Reader extends Value_union_Reader {
  const Value_struct_Reader(super.reader);

  $core.bool get hasValue => !reader.getPointer(0).isNull;
  $capnproto.AnyPointerReader get value =>
      $capnproto.AnyPointerReader(reader.getPointer(0));
}

class Value_struct_Builder extends Value_union_Builder {
  const Value_struct_Builder(super.builder);

  @$core.override
  Value_struct_Reader get asReader => Value_struct_Reader(builder.asReader);

  $core.bool get hasValue => !builder.getPointer(0).isNull;
  $capnproto.AnyPointerBuilder initValue() {
    final result = $capnproto.AnyPointerBuilder(builder.getPointer(0));
    result.clear();
    return result;
  }
}

/// The only interface value that can be represented statically is "null", whose methods always
/// throw exceptions.
class Value_interface_Reader extends Value_union_Reader {
  const Value_interface_Reader(super.reader);

  void get value {}
}

/// The only interface value that can be represented statically is "null", whose methods always
/// throw exceptions.
class Value_interface_Builder extends Value_union_Builder {
  const Value_interface_Builder(super.builder);

  @$core.override
  Value_interface_Reader get asReader =>
      Value_interface_Reader(builder.asReader);

  void get value {}
}

class Value_anyPointer_Reader extends Value_union_Reader {
  const Value_anyPointer_Reader(super.reader);

  $core.bool get hasValue => !reader.getPointer(0).isNull;
  $capnproto.AnyPointerReader get value =>
      $capnproto.AnyPointerReader(reader.getPointer(0));
}

class Value_anyPointer_Builder extends Value_union_Builder {
  const Value_anyPointer_Builder(super.builder);

  @$core.override
  Value_anyPointer_Reader get asReader =>
      Value_anyPointer_Reader(builder.asReader);

  $core.bool get hasValue => !builder.getPointer(0).isNull;
  $capnproto.AnyPointerBuilder initValue() {
    final result = $capnproto.AnyPointerBuilder(builder.getPointer(0));
    result.clear();
    return result;
  }
}

class Value_notInSchema_Reader extends Value_union_Reader {
  const Value_notInSchema_Reader(super.reader);
}

class Value_notInSchema_Builder extends Value_union_Builder {
  const Value_notInSchema_Builder(super.reader);

  @$core.override
  Value_notInSchema_Reader get asReader =>
      Value_notInSchema_Reader(builder.asReader);
}

// struct Annotation

/// Describes an annotation applied to a declaration.  Note AnnotationNode describes the
/// annotation's declaration, while this describes a use of the annotation.
class Annotation_Reader extends $capnproto.CapnpStructReader {
  const Annotation_Reader(super.reader);

  static const typeId = -1024405029288315582;

  /// ID of the annotation node.
  $core.int get id => reader.getUInt64(0, 0);

  $core.bool get hasValue => !reader.getPointer(0).isNull;
  Value_Reader get value =>
      Value_Reader(reader.getPointer(0).getStruct(null).unwrap());

  $core.bool get hasBrand => !reader.getPointer(1).isNull;

  /// Brand of the annotation.
  ///
  /// Note that the annotation itself is not allowed to be parameterized, but its scope might be.
  Brand_Reader get brand =>
      Brand_Reader(reader.getPointer(1).getStruct(null).unwrap());
}

/// Describes an annotation applied to a declaration.  Note AnnotationNode describes the
/// annotation's declaration, while this describes a use of the annotation.
class Annotation_Builder
    extends $capnproto.CapnpStructBuilder<Annotation_Reader> {
  const Annotation_Builder(super.builder);

  Annotation_Builder.initPointer($capnproto.PointerBuilder builder)
      : this(builder.initStruct(structSize));

  Annotation_Builder.getFromPointer(
    $capnproto.PointerBuilder builder,
    $typed_data.ByteData defaultValue,
  ) : this(builder.getStruct(structSize, defaultValue).unwrap());

  static const structSize =
      $capnproto.StructSize(dataWords: 1, pointerCount: 2);

  @$core.override
  Annotation_Reader get asReader => Annotation_Reader(builder.asReader);

  /// ID of the annotation node.
  $core.int get id {
    return builder.getUInt64(0, 0);
  }

  set id($core.int value) {
    return builder.setUInt64(0, value, 0);
  }

  $core.bool get hasValue => !builder.getPointer(0).isNull;
  Value_Builder getValue() {
    return Value_Builder(
      builder.getPointer(0).getStruct(Value_Builder.structSize, null).unwrap(),
    );
  }

  Value_Builder initValue() {
    return Value_Builder(
      builder.getPointer(0).initStruct(Value_Builder.structSize),
    );
  }

  $core.bool get hasBrand => !builder.getPointer(1).isNull;

  /// Brand of the annotation.
  ///
  /// Note that the annotation itself is not allowed to be parameterized, but its scope might be.
  Brand_Builder getBrand() {
    return Brand_Builder(
      builder.getPointer(1).getStruct(Brand_Builder.structSize, null).unwrap(),
    );
  }

  Brand_Builder initBrand() {
    return Brand_Builder(
      builder.getPointer(1).initStruct(Brand_Builder.structSize),
    );
  }
}

// enum ElementSize

/// Possible element sizes for encoded lists.  These correspond exactly to the possible values of
/// the 3-bit element size component of a list pointer.
enum ElementSize {
  /// aka "void", but that's a keyword.
  empty(0),
  bit(1),
  byte(2),
  twoBytes(3),
  fourBytes(4),
  eightBytes(5),
  pointer(6),
  inlineComposite(7),
  notInSchema(null);

  const ElementSize(this.value);

  factory ElementSize.fromValue($core.int value) {
    return switch (value) {
      0 => ElementSize.empty,
      1 => ElementSize.bit,
      2 => ElementSize.byte,
      3 => ElementSize.twoBytes,
      4 => ElementSize.fourBytes,
      5 => ElementSize.eightBytes,
      6 => ElementSize.pointer,
      7 => ElementSize.inlineComposite,
      _ => ElementSize.notInSchema,
    };
  }

  static const typeId = -3344609378093098714;

  final $core.int? value;
}

// struct CapnpVersion

class CapnpVersion_Reader extends $capnproto.CapnpStructReader {
  const CapnpVersion_Reader(super.reader);

  static const typeId = -2856073419177092765;

  $core.int get major => reader.getUInt16(0, 0);

  $core.int get minor => reader.getUInt8(2, 0);

  $core.int get micro => reader.getUInt8(3, 0);
}

class CapnpVersion_Builder
    extends $capnproto.CapnpStructBuilder<CapnpVersion_Reader> {
  const CapnpVersion_Builder(super.builder);

  CapnpVersion_Builder.initPointer($capnproto.PointerBuilder builder)
      : this(builder.initStruct(structSize));

  CapnpVersion_Builder.getFromPointer(
    $capnproto.PointerBuilder builder,
    $typed_data.ByteData defaultValue,
  ) : this(builder.getStruct(structSize, defaultValue).unwrap());

  static const structSize =
      $capnproto.StructSize(dataWords: 1, pointerCount: 0);

  @$core.override
  CapnpVersion_Reader get asReader => CapnpVersion_Reader(builder.asReader);

  $core.int get major {
    return builder.getUInt16(0, 0);
  }

  set major($core.int value) {
    return builder.setUInt16(0, value, 0);
  }

  $core.int get minor {
    return builder.getUInt8(2, 0);
  }

  set minor($core.int value) {
    return builder.setUInt8(2, value, 0);
  }

  $core.int get micro {
    return builder.getUInt8(3, 0);
  }

  set micro($core.int value) {
    return builder.setUInt8(3, value, 0);
  }
}

// struct CodeGeneratorRequest

class CodeGeneratorRequest_Reader extends $capnproto.CapnpStructReader {
  const CodeGeneratorRequest_Reader(super.reader);

  static const typeId = -4628215019123058738;

  $core.bool get hasNodes => !reader.getPointer(0).isNull;

  /// All nodes parsed by the compiler, including for the files on the command line and their
  /// imports.
  $capnproto.StructListReader<Node_Reader> get nodes {
    return $capnproto.StructListReader.getFromPointer(
      reader.getPointer(0),
      Node_Reader.new,
      null,
    ).unwrap();
  }

  $core.bool get hasRequestedFiles => !reader.getPointer(1).isNull;

  /// Files which were listed on the command line.
  $capnproto.StructListReader<CodeGeneratorRequest_RequestedFile_Reader>
      get requestedFiles {
    return $capnproto.StructListReader.getFromPointer(
      reader.getPointer(1),
      CodeGeneratorRequest_RequestedFile_Reader.new,
      null,
    ).unwrap();
  }

  $core.bool get hasCapnpVersion => !reader.getPointer(2).isNull;

  /// Version of the `capnp` executable. Generally, code generators should ignore this, but the code
  /// generators that ship with `capnp` itself will print a warning if this mismatches since that
  /// probably indicates something is misconfigured.
  ///
  /// The first version of 'capnp' to set this was 0.6.0. So, if it's missing, the compiler version
  /// is older than that.
  CapnpVersion_Reader get capnpVersion =>
      CapnpVersion_Reader(reader.getPointer(2).getStruct(null).unwrap());

  $core.bool get hasSourceInfo => !reader.getPointer(3).isNull;

  /// Information about the original source code for each node, where available. This array may be
  /// omitted or may be missing some nodes if no info is available for them.
  $capnproto.StructListReader<Node_SourceInfo_Reader> get sourceInfo {
    return $capnproto.StructListReader.getFromPointer(
      reader.getPointer(3),
      Node_SourceInfo_Reader.new,
      null,
    ).unwrap();
  }
}

class CodeGeneratorRequest_Builder
    extends $capnproto.CapnpStructBuilder<CodeGeneratorRequest_Reader> {
  const CodeGeneratorRequest_Builder(super.builder);

  CodeGeneratorRequest_Builder.initPointer($capnproto.PointerBuilder builder)
      : this(builder.initStruct(structSize));

  CodeGeneratorRequest_Builder.getFromPointer(
    $capnproto.PointerBuilder builder,
    $typed_data.ByteData defaultValue,
  ) : this(builder.getStruct(structSize, defaultValue).unwrap());

  static const structSize =
      $capnproto.StructSize(dataWords: 0, pointerCount: 4);

  @$core.override
  CodeGeneratorRequest_Reader get asReader =>
      CodeGeneratorRequest_Reader(builder.asReader);

  $core.bool get hasNodes => !builder.getPointer(0).isNull;

  /// All nodes parsed by the compiler, including for the files on the command line and their
  /// imports.
  $capnproto.StructListBuilder<Node_Builder, Node_Reader> get nodes {
    return $capnproto.StructListBuilder.getFromPointer(
      builder.getPointer(0),
      Node_Builder.structSize,
      Node_Builder.new,
      Node_Reader.new,
      null,
    ).unwrap();
  }

  $capnproto.StructListBuilder<Node_Builder, Node_Reader> initNodes(
    $core.int length,
  ) {
    return $capnproto.StructListBuilder.initPointer(
      builder.getPointer(0),
      length,
      Node_Builder.structSize,
      Node_Builder.new,
      Node_Reader.new,
    );
  }

  $core.bool get hasRequestedFiles => !builder.getPointer(1).isNull;

  /// Files which were listed on the command line.
  $capnproto.StructListBuilder<CodeGeneratorRequest_RequestedFile_Builder,
      CodeGeneratorRequest_RequestedFile_Reader> get requestedFiles {
    return $capnproto.StructListBuilder.getFromPointer(
      builder.getPointer(1),
      CodeGeneratorRequest_RequestedFile_Builder.structSize,
      CodeGeneratorRequest_RequestedFile_Builder.new,
      CodeGeneratorRequest_RequestedFile_Reader.new,
      null,
    ).unwrap();
  }

  $capnproto.StructListBuilder<CodeGeneratorRequest_RequestedFile_Builder,
          CodeGeneratorRequest_RequestedFile_Reader>
      initRequestedFiles($core.int length) {
    return $capnproto.StructListBuilder.initPointer(
      builder.getPointer(1),
      length,
      CodeGeneratorRequest_RequestedFile_Builder.structSize,
      CodeGeneratorRequest_RequestedFile_Builder.new,
      CodeGeneratorRequest_RequestedFile_Reader.new,
    );
  }

  $core.bool get hasCapnpVersion => !builder.getPointer(2).isNull;

  /// Version of the `capnp` executable. Generally, code generators should ignore this, but the code
  /// generators that ship with `capnp` itself will print a warning if this mismatches since that
  /// probably indicates something is misconfigured.
  ///
  /// The first version of 'capnp' to set this was 0.6.0. So, if it's missing, the compiler version
  /// is older than that.
  CapnpVersion_Builder getCapnpVersion() {
    return CapnpVersion_Builder(
      builder
          .getPointer(2)
          .getStruct(CapnpVersion_Builder.structSize, null)
          .unwrap(),
    );
  }

  CapnpVersion_Builder initCapnpVersion() {
    return CapnpVersion_Builder(
      builder.getPointer(2).initStruct(CapnpVersion_Builder.structSize),
    );
  }

  $core.bool get hasSourceInfo => !builder.getPointer(3).isNull;

  /// Information about the original source code for each node, where available. This array may be
  /// omitted or may be missing some nodes if no info is available for them.
  $capnproto.StructListBuilder<Node_SourceInfo_Builder, Node_SourceInfo_Reader>
      get sourceInfo {
    return $capnproto.StructListBuilder.getFromPointer(
      builder.getPointer(3),
      Node_SourceInfo_Builder.structSize,
      Node_SourceInfo_Builder.new,
      Node_SourceInfo_Reader.new,
      null,
    ).unwrap();
  }

  $capnproto.StructListBuilder<Node_SourceInfo_Builder, Node_SourceInfo_Reader>
      initSourceInfo($core.int length) {
    return $capnproto.StructListBuilder.initPointer(
      builder.getPointer(3),
      length,
      Node_SourceInfo_Builder.structSize,
      Node_SourceInfo_Builder.new,
      Node_SourceInfo_Reader.new,
    );
  }
}

// struct CodeGeneratorRequest.RequestedFile

class CodeGeneratorRequest_RequestedFile_Reader
    extends $capnproto.CapnpStructReader {
  const CodeGeneratorRequest_RequestedFile_Reader(super.reader);

  static const typeId = -3464940813450936222;

  /// ID of the file.
  $core.int get id => reader.getUInt64(0, 0);

  $core.bool get hasFilename => !reader.getPointer(0).isNull;

  /// Name of the file as it appeared on the command-line (minus the src-prefix).  You may use
  /// this to decide where to write the output.
  $core.String get filename => reader.getPointer(0).getText(null).unwrap();

  $core.bool get hasImports => !reader.getPointer(1).isNull;

  /// List of all imported paths seen in this file.
  $capnproto.StructListReader<CodeGeneratorRequest_RequestedFile_Import_Reader>
      get imports {
    return $capnproto.StructListReader.getFromPointer(
      reader.getPointer(1),
      CodeGeneratorRequest_RequestedFile_Import_Reader.new,
      null,
    ).unwrap();
  }
}

class CodeGeneratorRequest_RequestedFile_Builder extends $capnproto
    .CapnpStructBuilder<CodeGeneratorRequest_RequestedFile_Reader> {
  const CodeGeneratorRequest_RequestedFile_Builder(super.builder);

  CodeGeneratorRequest_RequestedFile_Builder.initPointer(
    $capnproto.PointerBuilder builder,
  ) : this(builder.initStruct(structSize));

  CodeGeneratorRequest_RequestedFile_Builder.getFromPointer(
    $capnproto.PointerBuilder builder,
    $typed_data.ByteData defaultValue,
  ) : this(builder.getStruct(structSize, defaultValue).unwrap());

  static const structSize =
      $capnproto.StructSize(dataWords: 1, pointerCount: 2);

  @$core.override
  CodeGeneratorRequest_RequestedFile_Reader get asReader =>
      CodeGeneratorRequest_RequestedFile_Reader(builder.asReader);

  /// ID of the file.
  $core.int get id {
    return builder.getUInt64(0, 0);
  }

  set id($core.int value) {
    return builder.setUInt64(0, value, 0);
  }

  $core.bool get hasFilename => !builder.getPointer(0).isNull;

  /// Name of the file as it appeared on the command-line (minus the src-prefix).  You may use
  /// this to decide where to write the output.
  $core.String get filename => builder.getPointer(0).getText(null).unwrap();
  set filename($core.String value) {
    builder.getPointer(0).setText(value);
  }

  $core.bool get hasImports => !builder.getPointer(1).isNull;

  /// List of all imported paths seen in this file.
  $capnproto.StructListBuilder<
      CodeGeneratorRequest_RequestedFile_Import_Builder,
      CodeGeneratorRequest_RequestedFile_Import_Reader> get imports {
    return $capnproto.StructListBuilder.getFromPointer(
      builder.getPointer(1),
      CodeGeneratorRequest_RequestedFile_Import_Builder.structSize,
      CodeGeneratorRequest_RequestedFile_Import_Builder.new,
      CodeGeneratorRequest_RequestedFile_Import_Reader.new,
      null,
    ).unwrap();
  }

  $capnproto.StructListBuilder<
          CodeGeneratorRequest_RequestedFile_Import_Builder,
          CodeGeneratorRequest_RequestedFile_Import_Reader>
      initImports($core.int length) {
    return $capnproto.StructListBuilder.initPointer(
      builder.getPointer(1),
      length,
      CodeGeneratorRequest_RequestedFile_Import_Builder.structSize,
      CodeGeneratorRequest_RequestedFile_Import_Builder.new,
      CodeGeneratorRequest_RequestedFile_Import_Reader.new,
    );
  }
}

// struct CodeGeneratorRequest.RequestedFile.Import

class CodeGeneratorRequest_RequestedFile_Import_Reader
    extends $capnproto.CapnpStructReader {
  const CodeGeneratorRequest_RequestedFile_Import_Reader(super.reader);

  static const typeId = -5886132613052934171;

  /// ID of the imported file.
  $core.int get id => reader.getUInt64(0, 0);

  $core.bool get hasName => !reader.getPointer(0).isNull;

  /// Name which *this* file used to refer to the foreign file.  This may be a relative name.
  /// This information is provided because it might be useful for code generation, e.g. to
  /// generate #include directives in C++.  We don't put this in Node.file because this
  /// information is only meaningful at compile time anyway.
  ///
  /// (On Zooko's triangle, this is the import's petname according to the importing file.)
  $core.String get name => reader.getPointer(0).getText(null).unwrap();
}

class CodeGeneratorRequest_RequestedFile_Import_Builder extends $capnproto
    .CapnpStructBuilder<CodeGeneratorRequest_RequestedFile_Import_Reader> {
  const CodeGeneratorRequest_RequestedFile_Import_Builder(super.builder);

  CodeGeneratorRequest_RequestedFile_Import_Builder.initPointer(
    $capnproto.PointerBuilder builder,
  ) : this(builder.initStruct(structSize));

  CodeGeneratorRequest_RequestedFile_Import_Builder.getFromPointer(
    $capnproto.PointerBuilder builder,
    $typed_data.ByteData defaultValue,
  ) : this(builder.getStruct(structSize, defaultValue).unwrap());

  static const structSize =
      $capnproto.StructSize(dataWords: 1, pointerCount: 1);

  @$core.override
  CodeGeneratorRequest_RequestedFile_Import_Reader get asReader =>
      CodeGeneratorRequest_RequestedFile_Import_Reader(builder.asReader);

  /// ID of the imported file.
  $core.int get id {
    return builder.getUInt64(0, 0);
  }

  set id($core.int value) {
    return builder.setUInt64(0, value, 0);
  }

  $core.bool get hasName => !builder.getPointer(0).isNull;

  /// Name which *this* file used to refer to the foreign file.  This may be a relative name.
  /// This information is provided because it might be useful for code generation, e.g. to
  /// generate #include directives in C++.  We don't put this in Node.file because this
  /// information is only meaningful at compile time anyway.
  ///
  /// (On Zooko's triangle, this is the import's petname according to the importing file.)
  $core.String get name => builder.getPointer(0).getText(null).unwrap();
  set name($core.String value) {
    builder.getPointer(0).setText(value);
  }
}
