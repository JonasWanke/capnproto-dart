import 'dart:io';

import 'package:collection/collection.dart';
import 'package:dart_style/dart_style.dart';
import 'package:path/path.dart' as path;

import 'constants.dart';
import 'imports.dart';
import 'schema.dart';

class CodeGenerationCommand {
  /// [extraImports] is a map from import URI to the file IDs that the import
  /// provides generated code for.
  // TODO(JonasWanke): generate code for the JSON schema and update/add these docs
  // # Example
  //
  // If you write a schema like so:
  //
  // ```capnp
  // // my_schema.capnp
  // using Json = import "/capnp/compat/json.capnp";
  //
  // struct Foo {
  //     value @0 :Json.Value;
  // }
  // ```
  //
  // You'd look at [json.capnp][json.capnp] to see its Cap'n Proto ID:
  //
  // ```capnp
  // // json.capnp
  // # Copyright (c) 2015 Sandstorm Development Group, Inc. and contributors
  // @0x8ef99297a43a5e34;
  // ```
  //
  // If you want the `foo::Builder::get_value` method generated for your
  // schema to return a `capnp_json::json_capnp::value::Reader`, add a
  // dependency on `capnp_json` to your `Cargo.toml` and specify it provides
  // `json.capnp` in your `build.rs`.
  //
  // ```
  // // build.rs
  //
  // capnpc::CompilerCommand::new()
  //     .crate_provides("json_capnp", [0x8ef99297a43a5e34])
  //     .file("my_schema.capnp")
  //     .run()
  //     .unwrap();
  // ```
  //
  // [json.capnp]: https://github.com/capnproto/capnproto/blob/master/c%2B%2B/src/capnp/compat/json.capnp
  CodeGenerationCommand({
    Directory? outputDirectory,
    Map<Uri, List<int>> extraImports = const {},
  }) : this.raw(
          outputDirectory: outputDirectory,
          extraImports: Map.fromEntries(
            extraImports.entries.expand(
              (entry) => entry.value.map((it) => MapEntry(it, entry.key)),
            ),
          ),
        );
  CodeGenerationCommand.raw({
    Directory? outputDirectory,
    this.extraImports = const {},
  }) : outputDirectory = outputDirectory ?? Directory.current;

  final Directory outputDirectory;

  /// A map from file ID to the import URI that provides the corresponding code.
  ///
  /// You only need this when your generated code needs to refer to types in
  /// an external package. If you just want to use an annotation and the
  /// argument to that annotation is a built-in type (e.g. `$Json.name`), this
  /// isn't necessary.
  final Map<int, Uri> extraImports;

  Future<void> run(CodeGeneratorRequest_Reader request) async {
    final context = GeneratorContext(this, request);
    await request.requestedFiles.map(context.generateFile).wait;
  }
}

class GeneratorContext {
  GeneratorContext(this.command, this.request) {
    for (final node in request.nodes) {
      nodeMap[node.id] = node;
      nodeParents[node.id] = node.scopeId;
    }

    // Fix up "anonymous" method params and results scopes.
    // for (final node in request.nodes) {
    //   if (node.which case final Node_interface_Reader interface) {
    //     for (final method in interface.methods) {
    //       final paramStructType = method.paramStructType;
    //       if (nodeParents[paramStructType] == 0) {
    //         nodeParents[paramStructType] = node.id;
    //       }
    //       final resultStructType = method.resultStructType;
    //       if (nodeParents[resultStructType] == 0) {
    //         nodeParents[resultStructType] = node.id;
    //       }
    //     }
    //   }
    // }

    for (final requestedFile in request.requestedFiles) {
      for (final import in requestedFile.imports) {
        if (command.extraImports[import.id] case final importUri?) {
          _populateImportsAndNames(importUri, import.id, '');
        }
      }

      _populateImportsAndNames(
        Uri.parse(requestedFile.dartFilename),
        requestedFile.id,
        '',
      );
    }
  }

  final CodeGenerationCommand command;
  final CodeGeneratorRequest_Reader request;
  final Map<int, Node_Reader> nodeMap = {};

  Node_struct_Reader getStruct(int nodeId) {
    final node = nodeMap[nodeId]!;
    final which = node.which;
    if (which is! Node_struct_Reader) {
      throw ArgumentError('Node $nodeId is not a struct');
    }
    return which;
  }

  /// Map from node ID to the node ID of its parent scope.
  ///
  /// This is equal to `node.scopeId` for all nodes except for autogenerated
  /// interface param and result structs: those have `scopeId` set to 0. See the
  /// comment on `paramStructType` in schema.capnp.
  final Map<int, int> nodeParents = {};

  final Map<int, ({Uri importUri, String name})> nodeImportsAndNames = {};

  void _populateImportsAndNames(Uri importUri, int nodeId, String nodeName) {
    // Unused nodes in imported files might be omitted from the node map;
    final node = nodeMap[nodeId];
    if (node == null) return;

    final name = node.annotations
            .where((it) => it.id == nameAnnotationId)
            .firstOrNull
            ?.nameAnnotationValue ??
        nodeName;

    nodeImportsAndNames[nodeId] = (importUri: importUri, name: name);

    final nestedNamePrefix = name.isEmpty ? '' : '${name}_';
    if (node.which case final Node_struct_Reader struct) {
      for (final field in struct.fields) {
        if (field.which case final Field_group_Reader group) {
          _populateImportsAndNames(
            importUri,
            group.typeId,
            '$nestedNamePrefix${field.annotations.dartNameAnnotationValue ?? field.name}',
          );
        }
      }
    }
    for (final nestedNode in node.nestedNodes) {
      _populateImportsAndNames(
        importUri,
        nestedNode.id,
        nestedNode.dartName(nestedNamePrefix).avoidDartKeywords(),
      );
    }
  }

  Future<void> generateFile(CodeGeneratorRequest_RequestedFile_Reader file) =>
      FileGenerator.generate(this, file);
}

class FileGenerator {
  FileGenerator._(this.context, Uri currentFile)
      : _imports = Imports(currentFile);

  static Future<void> generate(
    GeneratorContext context,
    CodeGeneratorRequest_RequestedFile_Reader file,
  ) async {
    final dartFile = File(
      path.join(context.command.outputDirectory.path, file.dartFilename),
    );
    await dartFile.parent.create(recursive: true);

    final generator = FileGenerator._(
      context,
      context.nodeImportsAndNames[file.id]!.importUri,
    );
    generator._generateNode(file.id);

    final output = StringBuffer();

    // We want to match this filter:
    // https://github.com/github-linguist/linguist/blob/1647b5be1658fb15a5e09bf89067f79b392301e2/lib/linguist/generated.rb#L712-L727
    output.writeln('// GENERATED CODE - DO NOT MODIFY BY HAND');
    output.writeln(
      "// Generated by the capnpc-dart plugin to the Cap'n Proto schema compiler.",
    );
    output.writeln('// Source: ${file.filename}');
    output.writeln();
    output.writeln('// ignore_for_file: camel_case_types');
    output.writeln();

    final codeBuffer = StringBuffer();
    generator._imports.addImportsToBuffer(codeBuffer);
    codeBuffer.writeln();
    for (final declarationBuffer in generator._declarations) {
      codeBuffer.writeln(declarationBuffer);
      codeBuffer.writeln();
    }
    final formatted = DartFormatter().format(codeBuffer.toString());
    output.write(formatted);

    await dartFile.writeAsString(output.toString());
  }

  final GeneratorContext context;

  final Imports _imports;
  final _declarations = <StringBuffer>[];
  StringBuffer _addDeclaration([String content = '']) {
    final buffer = StringBuffer(content);
    _declarations.add(buffer);
    return buffer;
  }

  void _generateNode(int nodeId, {String? superClass}) {
    final node = context.nodeMap[nodeId]!;
    final name = context.nodeImportsAndNames[nodeId]!.name;

    final nestedNodes = node.nestedNodes.toList();
    void generateConstantsAsStatic(StringBuffer buffer) {
      for (var i = 0; i < nestedNodes.length; i++) {
        final nestedNode = nestedNodes[i];
        if (context.nodeMap[nestedNode.id]!.which
            case final Node_const_Reader constant) {
          _generateConstant(
            buffer,
            nestedNode.dartName().avoidDartKeywords(),
            constant.type,
            constant.value,
            isStatic: true,
          );
          buffer.writeln();
          nestedNodes.removeAt(i);
          i--;
        }
      }
    }

    switch (node.which) {
      case Node_file_Reader():
        break;

      case final Node_struct_Reader struct:
        final buffer = _addDeclaration();

        buffer.writeln(
          '// ${struct.isGroup ? 'group' : 'struct'} ${node.shortDisplayName}',
        );
        buffer.writeln();

        buffer.writeln(
          'class ${name}_Reader '
          'extends ${superClass ?? _imports.capnpStructReader} {',
        );
        buffer.writeln('const ${name}_Reader(super.reader);');
        buffer.writeln();

        generateConstantsAsStatic(buffer);

        final unionFields = <Field_Reader>[];

        for (final field in struct.fields) {
          if (field.discriminantValue != Field_Reader.noDiscriminant) {
            unionFields.add(field);
          } else {
            switch (field.which) {
              case final Field_slot_Reader slot:
                _generateField(
                  buffer,
                  field.dartName.avoidDartKeywords(),
                  slot,
                );

              case Field_group_Reader(:final typeId):
                _generateNode(typeId);

              case Field_notInSchema_Reader():
                throw UnsupportedError('Unknown field type');
            }

            buffer.writeln();
          }
        }

        if (unionFields.isNotEmpty) {
          buffer.writeln('${name}_union_Reader get which {');
          buffer.writeln(
            // ignore: lines_longer_than_80_chars
            'return switch (reader.getUInt16(${struct.discriminantOffset}, 0)) {',
          );
          for (final unionField in unionFields) {
            final variantName = '${name}_${unionField.name}';
            buffer.writeln(
              // ignore: lines_longer_than_80_chars
              '${unionField.discriminantValue} => ${variantName}_Reader(reader),',
            );
          }
          buffer.writeln('_ => ${name}_notInSchema_Reader(reader),');
          buffer.writeln('};');
          buffer.writeln('}');
        }

        buffer.writeln('}');
        buffer.writeln();

        if (unionFields.isNotEmpty) {
          assert(unionFields.length >= 2);
          assert(unionFields.length == struct.discriminantCount);

          buffer.writeln(
            'sealed class ${name}_union_Reader '
            '    extends ${_imports.capnpStructReader} {\n'
            '  const ${name}_union_Reader(super.reader);\n'
            '}',
          );
          buffer.writeln();

          for (final unionField in unionFields) {
            switch (unionField.which) {
              case final Field_slot_Reader slot:
                final buffer = _addDeclaration();

                final variantName = '${name}_${unionField.dartName}';
                buffer.writeln(
                  'class ${variantName}_Reader extends ${name}_union_Reader {',
                );
                buffer.writeln('const ${variantName}_Reader(super.reader);');
                buffer.writeln();

                _generateField(buffer, 'value', slot);

                buffer.writeln('}');

              case Field_group_Reader(:final typeId):
                _generateNode(typeId, superClass: '${name}_union_Reader');

              case Field_notInSchema_Reader():
                throw UnsupportedError('Unknown field type');
            }
          }

          _addDeclaration(
            'class ${name}_notInSchema_Reader extends ${name}_union_Reader {\n'
            '  const ${name}_notInSchema_Reader(super.reader);\n'
            '}',
          );
        }

      case final Node_enum_Reader enum_:
        final buffer = _addDeclaration();
        buffer.writeln('// enum ${node.shortDisplayName}');
        buffer.writeln();

        buffer.writeln('enum $name {');
        for (final (value, entry) in enum_.enumerants.indexed) {
          buffer.writeln('${entry.dartName.avoidDartKeywords()}($value),');
        }
        buffer.writeln('notInSchema(null);');
        buffer.writeln();

        buffer.writeln('const $name(this.value);');
        buffer.writeln();

        buffer.writeln('factory $name.fromValue(${_imports.int} value) {');
        buffer.writeln('return switch (value) {');
        for (final (value, entry) in enum_.enumerants.indexed) {
          buffer.writeln(
            '$value => $name.${entry.dartName.avoidDartKeywords()},',
          );
        }
        buffer.writeln('_ => $name.notInSchema,');
        buffer.writeln('};');
        buffer.writeln('}');
        buffer.writeln();

        generateConstantsAsStatic(buffer);

        buffer.writeln('final ${_imports.int}? value;');
        buffer.writeln('}');

      case Node_interface_Reader():
        _addDeclaration('// TODO: codegen for interface');

      case Node_const_Reader(:final type, :final value):
        final buffer = _addDeclaration();
        _generateConstant(buffer, name, type, value, isStatic: false);

      case Node_annotation_Reader():
        break;

      case Node_notInSchema_Reader():
        throw UnsupportedError('Unknown node type');
    }

    for (final nestedNode in nestedNodes) {
      _generateNode(nestedNode.id);
    }
  }

  void _generateField(
    StringBuffer buffer,
    String name,
    Field_slot_Reader slot,
  ) {
    void generateHas() {
      buffer.writeln(
        '${_imports.bool} get has${name.capitalize()} => '
        '!reader.getPointer(${slot.offset}).isNull;',
      );
    }

    final defaultName = 'default${name.capitalize()}';
    final hasExplicitDefault = slot.hadExplicitDefault &&
        _generateConstant(
          buffer,
          defaultName,
          slot.type,
          slot.defaultValue,
          isStatic: true,
          onlyIfNotDefault: true,
        );
    final defaultValue = hasExplicitDefault ? defaultName : null;

    switch (slot.type.which) {
      case Type_void_Reader():
        buffer.writeln('void get $name {}');

      case Type_bool_Reader():
        buffer.writeln(
          '${_imports.bool} get $name => '
          'reader.getBool(${slot.offset}, ${defaultValue ?? false});',
        );

      case Type_int8_Reader():
        buffer.writeln(
          '${_imports.int} get $name => '
          'reader.getInt8(${slot.offset}, ${defaultValue ?? 0});',
        );
      case Type_int16_Reader():
        buffer.writeln(
          '${_imports.int} get $name => '
          'reader.getInt16(${slot.offset}, ${defaultValue ?? 0});',
        );
      case Type_int32_Reader():
        buffer.writeln(
          '${_imports.int} get $name => '
          'reader.getInt32(${slot.offset}, ${defaultValue ?? 0});',
        );
      case Type_int64_Reader():
        buffer.writeln(
          '${_imports.int} get $name => '
          'reader.getInt64(${slot.offset}, ${defaultValue ?? 0});',
        );
      case Type_uint8_Reader():
        buffer.writeln(
          '${_imports.int} get $name => '
          'reader.getUInt8(${slot.offset}, ${defaultValue ?? 0});',
        );
      case Type_uint16_Reader():
        buffer.writeln(
          '${_imports.int} get $name => '
          'reader.getUInt16(${slot.offset}, ${defaultValue ?? 0});',
        );
      case Type_uint32_Reader():
        buffer.writeln(
          '${_imports.int} get $name => '
          'reader.getUInt32(${slot.offset}, ${defaultValue ?? 0});',
        );
      case Type_uint64_Reader():
        buffer.writeln(
          '${_imports.int} get $name => '
          'reader.getUInt64(${slot.offset}, ${defaultValue ?? 0});',
        );

      case Type_float32_Reader():
        buffer.writeln(
          '${_imports.double} get $name => '
          // ignore: lines_longer_than_80_chars
          'reader.getFloat32(${slot.offset}, ${defaultValue == null ? '0' : '_${defaultValue}Bits'});',
        );
      case Type_float64_Reader():
        buffer.writeln(
          '${_imports.double} get $name => '
          // ignore: lines_longer_than_80_chars
          'reader.getFloat64(${slot.offset}, ${defaultValue == null ? '0' : '_${defaultValue}Bits'});',
        );

      case Type_text_Reader():
        generateHas();
        buffer.writeln(
          '${_imports.string} get $name => '
          // ignore: lines_longer_than_80_chars
          'reader.getPointer(${slot.offset}).getText($defaultValue).unwrap();',
        );
      case Type_data_Reader():
        generateHas();
        buffer.writeln(
          '${_imports.byteData} get $name => '
          // ignore: lines_longer_than_80_chars
          'reader.getPointer(${slot.offset}).getData($defaultValue).unwrap();',
        );

      case Type_list_Reader(:final elementType):
        generateHas();

        void generatePrimitiveList(String dartType, String capnpType) {
          buffer.writeln(
            '${_imports.primitiveListReader}<$dartType> get $name =>'
            // ignore: lines_longer_than_80_chars
            '${_imports.primitiveListReader}.${capnpType}FromPointer(reader.getPointer(${slot.offset}), $defaultValue).unwrap();',
          );
        }
        switch (elementType.which) {
          case Type_void_Reader():
            generatePrimitiveList('void', 'void');
          case Type_bool_Reader():
            generatePrimitiveList('bool', 'bool');
          case Type_int8_Reader():
            generatePrimitiveList('int', 'int8');
          case Type_int16_Reader():
            generatePrimitiveList('int', 'int16');
          case Type_int32_Reader():
            generatePrimitiveList('int', 'int32');
          case Type_int64_Reader():
            generatePrimitiveList('int', 'int64');
          case Type_uint8_Reader():
            generatePrimitiveList('int', 'uint8');
          case Type_uint16_Reader():
            generatePrimitiveList('int', 'uint16');
          case Type_uint32_Reader():
            generatePrimitiveList('int', 'uint32');
          case Type_uint64_Reader():
            generatePrimitiveList('int', 'uint64');
          case Type_float32_Reader():
            generatePrimitiveList('double', 'float32');
          case Type_float64_Reader():
            generatePrimitiveList('double', 'float64');
          case Type_text_Reader():
            buffer.writeln(
              '${_imports.textListReader} get $name =>'
              // ignore: lines_longer_than_80_chars
              '${_imports.textListReader}.getFromPointer(reader.getPointer(${slot.offset}), $defaultValue).unwrap();',
            );
          case Type_data_Reader():
            buffer.writeln(
              '${_imports.dataListReader} get $name =>'
              // ignore: lines_longer_than_80_chars
              '${_imports.dataListReader}.getFromPointer(reader.getPointer(${slot.offset}), $defaultValue).unwrap();',
            );
          case Type_list_Reader():
            buffer.writeln('// TODO: codegen field of type list of list');
          case Type_enum_Reader():
            buffer.writeln('// TODO: codegen field of type list of enum');
          case Type_struct_Reader(:final typeId):
            final elementType = context.nodeImportsAndNames[typeId]!;
            final elementTypeString =
                _imports.import(elementType.importUri, elementType.name);
            final listType = _imports.structListReader;
            buffer.writeln(
              '$listType<${elementTypeString}_Reader> get $name {\n'
              '  return $listType.fromPointer(\n'
              '  reader.getPointer(${slot.offset}),\n'
              '  ${elementTypeString}_Reader.new,\n'
              '  $defaultValue,\n'
              '  ).unwrap();\n'
              '}',
            );

          case Type_interface_Reader():
            buffer.writeln(
              '// TODO: codegen field of type list of interface',
            );
          case Type_anyPointer_Reader():
            buffer.writeln(
              '// TODO: codegen field of type list of AnyPointer',
            );
          case Type_notInSchema_Reader():
            throw UnsupportedError('Unknown list element type');
        }

      case Type_enum_Reader():
        buffer.writeln('// TODO: codegen for enum-typed field');

      case Type_struct_Reader(:final typeId):
        generateHas();

        final type = context.nodeImportsAndNames[typeId]!;
        final typeString = _imports.import(type.importUri, type.name);
        buffer.writeln(
          '${typeString}_Reader get $name => '
          // ignore: lines_longer_than_80_chars
          '${typeString}_Reader(reader.getPointer(${slot.offset}).getStruct($defaultValue).unwrap());',
        );

      case Type_interface_Reader():
        buffer.writeln('// TODO: codegen for interface-typed field');

      case Type_anyPointer_Reader():
        if (defaultValue != null) {
          throw UnsupportedError(
            'Default value for AnyPointer-typed field is unsupported',
          );
        }

        generateHas();

        buffer.writeln(
          '${_imports.anyPointerReader} get $name => '
          // ignore: lines_longer_than_80_chars
          '${_imports.anyPointerReader}(reader.getPointer(${slot.offset}));',
        );

      default:
        throw ArgumentError("Field's type and default value don't match.");
    }
  }

  bool _generateConstant(
    StringBuffer buffer,
    String name,
    Type_Reader type,
    Value_Reader value, {
    required bool isStatic,
    bool onlyIfNotDefault = false,
  }) {
    final staticString = isStatic ? 'static' : '';

    switch ((type.which, value.which)) {
      case (Type_void_Reader(), Value_void_Reader()):
        if (onlyIfNotDefault) return false;

        buffer.writeln('$staticString const $name = null;');

      case (Type_bool_Reader(), Value_bool_Reader(:final value)):
        // ignore: no_literal_bool_comparisons, no-boolean-literal-compare
        if (onlyIfNotDefault && value == false) return false;

        buffer.writeln('$staticString const $name = $value;');

      case (Type_int8_Reader(), Value_int8_Reader(:final num value)) ||
            (Type_int16_Reader(), Value_int16_Reader(:final num value)) ||
            (Type_int32_Reader(), Value_int32_Reader(:final num value)) ||
            (Type_int64_Reader(), Value_int64_Reader(:final num value)) ||
            (Type_uint8_Reader(), Value_uint8_Reader(:final num value)) ||
            (Type_uint16_Reader(), Value_uint16_Reader(:final num value)) ||
            (Type_uint32_Reader(), Value_uint32_Reader(:final num value)) ||
            (Type_uint64_Reader(), Value_uint64_Reader(:final num value)):
        if (onlyIfNotDefault && value == 0) return false;

        buffer.writeln('$staticString const $name = $value;');

      case (
          Type_float32_Reader(),
          Value_float32_Reader(:final reader, :final num value),
        ):
        if (onlyIfNotDefault && value == 0) return false;

        buffer.writeln('$staticString const $name = $value;');
        buffer.writeln(
          // ignore: lines_longer_than_80_chars
          '$staticString final _${name}Bits = ${reader.getUInt32(1, 0).toRadixString(16).padLeft(8, '0')};',
        );
      case (
          Type_float64_Reader(),
          Value_float64_Reader(:final reader, :final num value),
        ):
        if (onlyIfNotDefault && value == 0) return false;

        buffer.writeln('$staticString const $name = $value;');
        buffer.writeln(
          // ignore: lines_longer_than_80_chars
          '$staticString final _${name}Bits = ${reader.getUInt32(1, 0).toRadixString(16).padLeft(16, '0')};',
        );

      case (Type_text_Reader(), Value_text_Reader(:final value)):
        if (onlyIfNotDefault && value == '') return false;

        buffer.writeln(
          '$staticString const $name = '
          "'${value.replaceAll("'", r"\'").replaceAll('\n', r'\n')}';",
        );

      case (Type_data_Reader(), Value_data_Reader(:final value)):
        if (onlyIfNotDefault && value.lengthInBytes == 0) return false;

        generateConstantData(name, value, buffer, isStatic: isStatic);

      case (Type_enum_Reader(:final typeId), Value_enum_Reader(:final value)):
        if (onlyIfNotDefault && value == 0) return false;

        final type = context.nodeMap[typeId]!;
        final enumType = context.nodeImportsAndNames[typeId]!;
        final enumTypeString =
            _imports.import(enumType.importUri, enumType.name);

        if (type.which case final Node_enum_Reader enum_) {
          final enumerant = enum_.enumerants[value];
          buffer.writeln(
            '$staticString const $name = $enumTypeString.${enumerant.name};',
          );
        } else {
          throw ArgumentError('Type is not an enum');
        }

      case (
          Type_list_Reader(:final elementType),
          Value_list_Reader(:final value),
        ):
        final reference = generateConstantPointerReader(
          name,
          value,
          buffer,
          isStatic: isStatic,
        );

        buffer.write('$staticString final $name = ');
        void generatePrimitiveList(String capnpType) {
          buffer.writeln(
            // ignore: lines_longer_than_80_chars
            '${_imports.primitiveListReader}.${capnpType}FromPointer($reference, null).unwrap();',
          );
        }
        switch (elementType.which) {
          case Type_void_Reader():
            generatePrimitiveList('void');
          case Type_bool_Reader():
            generatePrimitiveList('bool');
          case Type_int8_Reader():
            generatePrimitiveList('int8');
          case Type_int16_Reader():
            generatePrimitiveList('int16');
          case Type_int32_Reader():
            generatePrimitiveList('int32');
          case Type_int64_Reader():
            generatePrimitiveList('int64');
          case Type_uint8_Reader():
            generatePrimitiveList('uint8');
          case Type_uint16_Reader():
            generatePrimitiveList('uint16');
          case Type_uint32_Reader():
            generatePrimitiveList('uint32');
          case Type_uint64_Reader():
            generatePrimitiveList('uint64');
          case Type_float32_Reader():
            generatePrimitiveList('float32');
          case Type_float64_Reader():
            generatePrimitiveList('float64');
          case Type_text_Reader():
            buffer.writeln(
              // ignore: lines_longer_than_80_chars
              '${_imports.textListReader}.getFromPointer($reference, null).unwrap();',
            );
          case Type_data_Reader():
            buffer.writeln(
              // ignore: lines_longer_than_80_chars
              '${_imports.dataListReader}.getFromPointer($reference, null).unwrap();',
            );
          case Type_list_Reader():
            buffer.writeln('// TODO: codegen field of type list of list');
          case Type_enum_Reader():
            buffer.writeln('// TODO: codegen field of type list of enum');
          case Type_struct_Reader(:final typeId):
            final elementType = context.nodeImportsAndNames[typeId]!;
            final elementTypeString =
                _imports.import(elementType.importUri, elementType.name);
            final listType = _imports.structListReader;
            buffer.writeln(
              // ignore: lines_longer_than_80_chars
              '$listType.fromPointer($reference, ${elementTypeString}_Reader.new, null).unwrap();',
            );

          case Type_interface_Reader():
            buffer.writeln(
              '// TODO: codegen field of type list of interface',
            );
          case Type_anyPointer_Reader():
            buffer.writeln(
              '// TODO: codegen field of type list of AnyPointer',
            );
          case Type_notInSchema_Reader():
            throw UnsupportedError('Unknown list element type');
        }

      case (
          Type_struct_Reader(:final typeId),
          Value_struct_Reader(:final value),
        ):
        final reference = generateConstantPointerReader(
          name,
          value,
          buffer,
          isStatic: isStatic,
        );

        final type = context.nodeImportsAndNames[typeId]!;
        final typeString = _imports.import(type.importUri, type.name);
        buffer.writeln(
          '$staticString final $name = '
          '${typeString}_Reader($reference.getStruct(null).unwrap());',
        );

      case (Type_interface_Reader(), Value_interface_Reader()):
        return false;

      case (Type_anyPointer_Reader(), Value_anyPointer_Reader(:final value)):
        final reference = generateConstantPointerReader(
          name,
          value,
          buffer,
          isStatic: isStatic,
        );

        buffer.writeln(
          '$staticString final $name = '
          '${_imports.anyPointerReader}($reference);',
        );

      case (Type_notInSchema_Reader(), Value_notInSchema_Reader()):
        throw UnimplementedError('Interface constants are not yet supported');

      default:
        throw ArgumentError("Type and value don't match.");
    }
    return true;
  }
}

extension on CodeGeneratorRequest_RequestedFile_Reader {
  String get dartFilename => path.setExtension(filename, '.dart');
}

extension on Node_Reader {
  String get shortDisplayName =>
      displayName.substring(displayName.lastIndexOf(':') + 1);
}

extension on Node_NestedNode_Reader {
  String dartName([String prefix = '']) => '$prefix$name';
}

extension on Enumerant_Reader {
  String get dartName => annotations.dartNameAnnotationValue ?? name;
}

extension on Field_Reader {
  String get dartName => annotations.dartNameAnnotationValue ?? name;
}

extension on Iterable<Annotation_Reader> {
  String? get dartNameAnnotationValue =>
      where((it) => it.id == nameAnnotationId).firstOrNull?.nameAnnotationValue;
}

extension on Annotation_Reader {
  String get nameAnnotationValue {
    assert(id == nameAnnotationId);

    if (value.which case Value_text_Reader(value: final name)) {
      if (name.isEmpty) {
        throw ArgumentError('`dart.name` annotation value must not be empty');
      } else if (_dartKeywordsToAvoid.contains(name)) {
        throw ArgumentError(
          '`dart.name` annotation value must not be a reserved Dart keyword, '
          'but is `$name`.',
        );
      } else if (!RegExp(r'^[A-Za-z0-9_]$').hasMatch(name)) {
        throw ArgumentError(
          '`dart.name` annotation value must only contain alphanumeric '
          'characters and `_`, but is `$name`.',
        );
      }
      return name;
    } else {
      throw ArgumentError('`dart.name` annotation value must be of type Text');
    }
  }
}

// https://dart.dev/language/keywords
//
// Keywords that “can be used as an identifier without restriction”:
// `async`, `base`, `hide`, `of`, `on`, `sealed`, `show`, `sync`, `when`
const _dartKeywordsToAvoid = {
  //
  'abstract', 'as', 'assert', 'await', 'break', 'case', 'catch', 'class',
  'const', 'continue', 'covariant', 'default', 'deferred', 'do', 'dynamic',
  'else', 'enum', 'export', 'extends', 'extension', 'external', 'factory',
  'false', 'final', 'finally', 'for', 'Function', 'get', 'if', 'implements',
  'import', 'in', 'interface', 'is', 'late', 'library', 'mixin', 'new', 'null',
  'operator', 'part', 'required', 'rethrow', 'return', 'set', 'static', 'super',
  'switch', 'this', 'throw', 'true', 'try', 'type', 'typedef', 'var', 'void',
  'with', 'while', 'yield',
};

extension on String {
  String capitalize() => substring(0, 1).toUpperCase() + substring(1);

  String avoidDartKeywords() =>
      _dartKeywordsToAvoid.contains(this) ? '${this}_' : this;
}

// Annotation IDs as defined in `dart.capnp`.
// ignore: avoid_js_rounded_ints
const nameAnnotationId = 0xec209b3bbf6afb0f;
// ignore: avoid_js_rounded_ints
const nullableAnnotationId = 0x8f48ef3fdb930cd2;
