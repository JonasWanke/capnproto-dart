import 'dart:io';

import 'package:collection/collection.dart';
import 'package:dart_style/dart_style.dart';
import 'package:path/path.dart' as path;

import 'constants.dart';
import 'imports.dart';
import 'schema.dart';

class CodeGenerationCommand {
  /// [extraImports] is a map from import URI to the file IDs that the import
  /// provides generated code for.
  // TODO(JonasWanke): generate code for the JSON schema and update/add these docs
  // # Example
  //
  // If you write a schema like so:
  //
  // ```capnp
  // // my_schema.capnp
  // using Json = import "/capnp/compat/json.capnp";
  //
  // struct Foo {
  //     value @0 :Json.Value;
  // }
  // ```
  //
  // You'd look at [json.capnp][json.capnp] to see its Cap'n Proto ID:
  //
  // ```capnp
  // // json.capnp
  // # Copyright (c) 2015 Sandstorm Development Group, Inc. and contributors
  // @0x8ef99297a43a5e34;
  // ```
  //
  // If you want the `foo::Builder::get_value` method generated for your
  // schema to return a `capnp_json::json_capnp::value::Reader`, add a
  // dependency on `capnp_json` to your `Cargo.toml` and specify it provides
  // `json.capnp` in your `build.rs`.
  //
  // ```
  // // build.rs
  //
  // capnpc::CompilerCommand::new()
  //     .crate_provides("json_capnp", [0x8ef99297a43a5e34])
  //     .file("my_schema.capnp")
  //     .run()
  //     .unwrap();
  // ```
  //
  // [json.capnp]: https://github.com/capnproto/capnproto/blob/master/c%2B%2B/src/capnp/compat/json.capnp
  CodeGenerationCommand({
    Directory? outputDirectory,
    Map<Uri, List<int>> extraImports = const {},
  }) : this.raw(
          outputDirectory: outputDirectory,
          extraImports: Map.fromEntries(
            extraImports.entries.expand(
              (entry) => entry.value.map((it) => MapEntry(it, entry.key)),
            ),
          ),
        );
  CodeGenerationCommand.raw({
    Directory? outputDirectory,
    this.extraImports = const {},
  }) : outputDirectory = outputDirectory ?? Directory.current;

  final Directory outputDirectory;

  /// A map from file ID to the import URI that provides the corresponding code.
  ///
  /// You only need this when your generated code needs to refer to types in
  /// an external package. If you just want to use an annotation and the
  /// argument to that annotation is a built-in type (e.g. `$Json.name`), this
  /// isn't necessary.
  final Map<int, Uri> extraImports;

  Future<void> run(CodeGeneratorRequest_Reader request) async {
    final context = GeneratorContext(this, request);
    await request.requestedFiles.map(context.generateFile).wait;
  }
}

class GeneratorContext {
  GeneratorContext(this.command, this.request) {
    for (final node in request.nodes) {
      nodeMap[node.id] = node;
      nodeParents[node.id] = node.scopeId;
    }

    // Fix up "anonymous" method params and results scopes.
    // for (final node in request.nodes) {
    //   if (node.which case final Node_Which_Interface_Reader interface) {
    //     for (final method in interface.methods) {
    //       final paramStructType = method.paramStructType;
    //       if (nodeParents[paramStructType] == 0) {
    //         nodeParents[paramStructType] = node.id;
    //       }
    //       final resultStructType = method.resultStructType;
    //       if (nodeParents[resultStructType] == 0) {
    //         nodeParents[resultStructType] = node.id;
    //       }
    //     }
    //   }
    // }

    for (final requestedFile in request.requestedFiles) {
      for (final import in requestedFile.imports) {
        if (command.extraImports[import.id] case final importUri?) {
          _populateImportsAndNames(importUri, import.id, '');
        }
      }

      _populateImportsAndNames(
        Uri.parse(requestedFile.dartFilename),
        requestedFile.id,
        '',
      );
    }
  }

  final CodeGenerationCommand command;
  final CodeGeneratorRequest_Reader request;
  final Map<int, Node_Reader> nodeMap = {};

  /// Map from node ID to the node ID of its parent scope.
  ///
  /// This is equal to `node.scopeId` for all nodes except for autogenerated
  /// interface param and result structs: those have `scopeId` set to 0. See the
  /// comment on `paramStructType` in schema.capnp.
  final Map<int, int> nodeParents = {};

  final Map<int, ({Uri importUri, String name})> nodeImportsAndNames = {};

  void _populateImportsAndNames(
    Uri importUri,
    int nodeId,
    String nodeName, {
    String namePrefix = '',
  }) {
    // Unused nodes in imported files might be omitted from the node map;
    final node = nodeMap[nodeId];
    if (node == null) return;

    final name = node.annotations
            .where((it) => it.id == nameAnnotationId)
            .firstOrNull
            ?.nameAnnotationValue ??
        '$namePrefix$nodeName';

    nodeImportsAndNames[nodeId] = (importUri: importUri, name: name);
    for (final nestedNode in node.nestedNodes) {
      _populateImportsAndNames(
        importUri,
        nestedNode.id,
        nestedNode.name,
        namePrefix: name.isEmpty ? '' : '${name}_',
      );
    }
  }

  Future<void> generateFile(CodeGeneratorRequest_RequestedFile_Reader file) =>
      FileGenerator.generate(this, file);
}

class FileGenerator {
  FileGenerator._(this.context, Uri currentFile)
      : _imports = Imports(currentFile);

  static Future<void> generate(
    GeneratorContext context,
    CodeGeneratorRequest_RequestedFile_Reader file,
  ) async {
    final dartFile = File(
      path.join(context.command.outputDirectory.path, file.dartFilename),
    );
    await dartFile.parent.create(recursive: true);

    final generator = FileGenerator._(
      context,
      context.nodeImportsAndNames[file.id]!.importUri,
    );
    generator._generateNode(file.id);

    final output = StringBuffer();

    // We want to match this filter:
    // https://github.com/github-linguist/linguist/blob/1647b5be1658fb15a5e09bf89067f79b392301e2/lib/linguist/generated.rb#L712-L727
    output.writeln('// GENERATED CODE - DO NOT MODIFY BY HAND');
    output.writeln(
      "// Generated by the capnpc-dart plugin to the Cap'n Proto schema compiler.",
    );
    output.writeln('// Source: ${file.filename}');
    output.writeln();

    final codeBuffer = StringBuffer();
    generator._imports.addImportsToBuffer(codeBuffer);
    codeBuffer.writeln();
    codeBuffer.writeln(generator._buffer);
    final formatted = DartFormatter().format(codeBuffer.toString());
    output.write(formatted);

    await dartFile.writeAsString(output.toString());
  }

  final GeneratorContext context;

  final Imports _imports;
  final _buffer = StringBuffer();

  void _generateNode(int nodeId) {
    final node = context.nodeMap[nodeId]!;
    final name = context.nodeImportsAndNames[nodeId]!.name;

    switch (node.which) {
      case Node_Which_File_Reader():
        break;
      case final Node_Which_Struct_Reader struct:
        _buffer.writeln('// struct ${node.shortDisplayName}');
        _buffer.writeln();

        _buffer.writeln('// ignore: camel_case_types');
        _buffer.writeln(
          'final class ${name}_Reader extends ${_imports.capnpStructReader} {',
        );
        _buffer.writeln('const ${name}_Reader(super.reader);');
        _buffer.writeln();

        for (final field in struct.fields) {
          _generateField(field);
          _buffer.writeln();
        }

        _buffer.writeln('}');

      case final Node_Which_Enum_Reader enum_:
        _buffer.writeln('// enum ${node.shortDisplayName}');
        _buffer.writeln();

        if (name.contains('_')) _buffer.writeln('// ignore: camel_case_types');
        _buffer.writeln('enum $name {');
        for (final (value, entry) in enum_.enumerants.indexed) {
          _buffer.writeln('${entry.dartName}($value),');
        }
        _buffer.writeln('notInSchema(null);');
        _buffer.writeln();

        _buffer.writeln('const $name(this.value);');
        _buffer.writeln();

        _buffer.writeln('factory $name.fromValue(${_imports.int} value) {');
        _buffer.writeln('return switch (value) {');
        for (final (value, entry) in enum_.enumerants.indexed) {
          _buffer.writeln('$value => $name.${entry.dartName},');
        }
        _buffer.writeln('_ => $name.notInSchema,');
        _buffer.writeln('};');
        _buffer.writeln('}');
        _buffer.writeln();

        _buffer.writeln('final ${_imports.int}? value;');
        _buffer.writeln('}');

      case Node_Which_Interface_Reader():
        _buffer.writeln('// TODO: codegen for interface');

      case Node_Which_Const_Reader():
        _buffer.writeln('// TODO: codegen for const');

      case Node_Which_Annotation_Reader():
        break;

      case Node_Which_NotInSchema_Reader():
        throw UnsupportedError('Unknown node type');
    }
    _buffer.writeln();

    for (final nestedNode in node.nestedNodes) {
      _generateNode(nestedNode.id);
    }
  }

  void _generateField(Field_Reader field) {
    final name = field.dartName;
    switch (field.which) {
      case final Field_Which_Slot_Reader slot:
        void generateHas() {
          _buffer.writeln(
            '${_imports.bool} get has${name.capitalize()} => '
            '!reader.getPointer(${slot.offset}).isNull;',
          );
        }

        final defaultName = '_default${name.capitalize()}';

        switch ((slot.type.which, slot.defaultValue.which)) {
          case (Type_Which_Void_Reader(), Value_Which_Void_Reader()):
            _buffer.writeln('void get $name {}');

          case (
              Type_Which_Bool_Reader(),
              Value_Which_Bool_Reader(:final value)
            ):
            _buffer.writeln(
              '${_imports.bool} get $name => '
              'reader.getBool(${slot.offset}, $value);',
            );

          case (
              Type_Which_Int8_Reader(),
              Value_Which_Int8_Reader(:final value)
            ):
            _buffer.writeln(
              '${_imports.int} get $name => '
              'reader.getInt8(${slot.offset}, $value);',
            );
          case (
              Type_Which_Int16_Reader(),
              Value_Which_Int16_Reader(:final value)
            ):
            _buffer.writeln(
              '${_imports.int} get $name => '
              'reader.getInt16(${slot.offset}, $value);',
            );
          case (
              Type_Which_Int32_Reader(),
              Value_Which_Int32_Reader(:final value)
            ):
            _buffer.writeln(
              '${_imports.int} get $name => '
              'reader.getInt32(${slot.offset}, $value);',
            );
          case (
              Type_Which_Int64_Reader(),
              Value_Which_Int64_Reader(:final value)
            ):
            _buffer.writeln(
              '${_imports.int} get $name => '
              'reader.getInt64(${slot.offset}, $value);',
            );
          case (
              Type_Which_Uint8_Reader(),
              Value_Which_Uint8_Reader(:final value)
            ):
            _buffer.writeln(
              '${_imports.int} get $name => '
              'reader.getUInt8(${slot.offset}, $value);',
            );
          case (
              Type_Which_Uint16_Reader(),
              Value_Which_Uint16_Reader(:final value)
            ):
            _buffer.writeln(
              '${_imports.int} get $name => '
              'reader.getUInt16(${slot.offset}, $value);',
            );
          case (
              Type_Which_Uint32_Reader(),
              Value_Which_Uint32_Reader(:final value),
            ):
            _buffer.writeln(
              '${_imports.int} get $name => '
              'reader.getUInt32(${slot.offset}, $value);',
            );
          case (
              Type_Which_Uint64_Reader(),
              Value_Which_Uint64_Reader(:final value),
            ):
            _buffer.writeln(
              '${_imports.int} get $name => '
              'reader.getUInt64(${slot.offset}, $value);',
            );

          case (
              Type_Which_Float32_Reader(),
              Value_Which_Float32_Reader(reader: final valueReader),
            ):
            _buffer.writeln(
              '${_imports.double} get $name => '
              // ignore: lines_longer_than_80_chars
              'reader.getFloat32(${slot.offset}, ${valueReader.getUInt32(1, 0)});',
            );
          case (
              Type_Which_Float64_Reader(),
              Value_Which_Float64_Reader(reader: final valueReader),
            ):
            _buffer.writeln(
              '${_imports.double} get $name => '
              // ignore: lines_longer_than_80_chars
              'reader.getFloat64(${slot.offset}, ${valueReader.getUInt64(1, 0)});',
            );

          case (
              Type_Which_Text_Reader(),
              Value_Which_Text_Reader(:final value),
            ):
            if (value != '') {
              _buffer.writeln('// TODO: codegen default value for text field');
            }
            generateHas();
            _buffer.writeln(
              '${_imports.string} get $name => '
              'reader.getPointer(${slot.offset}).getText(null).unwrap();',
            );
          case (
              Type_Which_Data_Reader(),
              Value_Which_Data_Reader(:final value)
            ):
            if (value.lengthInBytes > 0) {
              _buffer.writeln('// TODO: codegen default value for data field');
            }
            generateHas();
            _buffer.writeln(
              '${_imports.byteData} get $name => '
              'reader.getPointer(${slot.offset}).getData(null).unwrap();',
            );

          case (
              Type_Which_List_Reader(:final elementType),
              Value_Which_List_Reader(:final value),
            ):
            generateHas();

            if (slot.hadExplicitDefault) {
              generateConstant(defaultName, value, _buffer).unwrap();
            }
            final defaultValue = slot.hadExplicitDefault ? defaultName : null;

            void generatePrimitiveList(String dartType, String capnpType) {
              _buffer.writeln(
                '${_imports.primitiveListReader}<$dartType> get $name =>'
                // ignore: lines_longer_than_80_chars
                '${_imports.primitiveListReader}.${capnpType}FromPointer(reader.getPointer(${slot.offset}), $defaultValue).unwrap();',
              );
            }
            switch (elementType.which) {
              case Type_Which_Void_Reader():
                generatePrimitiveList('void', 'void');
              case Type_Which_Bool_Reader():
                generatePrimitiveList('bool', 'bool');
              case Type_Which_Int8_Reader():
                generatePrimitiveList('int', 'int8');
              case Type_Which_Int16_Reader():
                generatePrimitiveList('int', 'int16');
              case Type_Which_Int32_Reader():
                generatePrimitiveList('int', 'int32');
              case Type_Which_Int64_Reader():
                generatePrimitiveList('int', 'int64');
              case Type_Which_Uint8_Reader():
                generatePrimitiveList('int', 'uint8');
              case Type_Which_Uint16_Reader():
                generatePrimitiveList('int', 'uint16');
              case Type_Which_Uint32_Reader():
                generatePrimitiveList('int', 'uint32');
              case Type_Which_Uint64_Reader():
                generatePrimitiveList('int', 'uint64');
              case Type_Which_Float32_Reader():
                generatePrimitiveList('double', 'float32');
              case Type_Which_Float64_Reader():
                generatePrimitiveList('double', 'float64');
              case Type_Which_Text_Reader():
                _buffer.writeln(
                  '${_imports.textListReader} get $name =>'
                  // ignore: lines_longer_than_80_chars
                  '${_imports.textListReader}.getFromPointer(reader.getPointer(${slot.offset}), $defaultValue).unwrap();',
                );
              case Type_Which_Data_Reader():
                _buffer.writeln(
                  '${_imports.dataListReader} get $name =>'
                  // ignore: lines_longer_than_80_chars
                  '${_imports.dataListReader}.getFromPointer(reader.getPointer(${slot.offset}), $defaultValue).unwrap();',
                );
              case Type_Which_List_Reader():
                _buffer.writeln('// TODO: codegen field of type list of list');
              case Type_Which_Enum_Reader():
                _buffer.writeln('// TODO: codegen field of type list of enum');
              case Type_Which_Struct_Reader(:final typeId):
                final elementType = context.nodeImportsAndNames[typeId]!;
                final elementTypeString =
                    _imports.import(elementType.importUri, elementType.name);
                final listType = _imports.structListReader;
                _buffer.writeln(
                  '$listType<${elementTypeString}_Reader> get $name {\n'
                  '  return $listType.fromPointer(\n'
                  '  reader.getPointer(${slot.offset}),\n'
                  '  ${elementTypeString}_Reader.new,\n'
                  '  $defaultValue,\n'
                  '  ).unwrap();\n'
                  '}',
                );

              case Type_Which_Interface_Reader():
                _buffer.writeln(
                  '// TODO: codegen field of type list of interface',
                );
              case Type_Which_AnyPointer_Reader():
                _buffer.writeln(
                  '// TODO: codegen field of type list of AnyPointer',
                );
              case Type_Which_NotInSchema_Reader():
                throw UnsupportedError('Unknown list element type');
            }

          case (
              Type_Which_Enum_Reader(),
              Value_Which_Enum_Reader(:final value),
            ):
            _buffer.writeln('// TODO: codegen for enum-typed field');

          case (
              Type_Which_Struct_Reader(:final typeId),
              Value_Which_Struct_Reader(:final value),
            ):
            generateHas();

            if (slot.hadExplicitDefault) {
              generateConstant(defaultName, value, _buffer).unwrap();
            }
            final type = context.nodeImportsAndNames[typeId]!;
            final typeString = _imports.import(type.importUri, type.name);
            _buffer.writeln(
              '${typeString}_Reader get $name => '
              // ignore: lines_longer_than_80_chars
              '${typeString}_Reader(reader.getPointer(${slot.offset}).getStruct(${slot.hadExplicitDefault ? defaultName : null}).unwrap());',
            );

          case (Type_Which_Interface_Reader(), Value_Which_Interface_Reader()):
            _buffer.writeln('// TODO: codegen for interface-typed field');

          case (
              Type_Which_AnyPointer_Reader(),
              Value_Which_AnyPointer_Reader(),
            ):
            _buffer.writeln('// TODO: codegen for AnyPointer-typed field');

          default:
            throw ArgumentError("Field's type and default value don't match.");
        }

      case Field_Which_Group_Reader():
        _buffer.writeln('// TODO: codegen for group');

      case Field_Which_NotInSchema_Reader():
        throw UnsupportedError('Unknown field type');
    }
  }
}

extension on CodeGeneratorRequest_RequestedFile_Reader {
  String get dartFilename => path.setExtension(filename, '.dart');
}

extension on Node_Reader {
  String get shortDisplayName =>
      displayName.substring(displayName.lastIndexOf(':') + 1);
}

extension on Enumerant_Reader {
  String get dartName =>
      annotations.dartNameAnnotationValue ?? name.avoidDartKeywords();
}

extension on Field_Reader {
  String get dartName =>
      annotations.dartNameAnnotationValue ?? name.avoidDartKeywords();
}

extension on Iterable<Annotation_Reader> {
  String? get dartNameAnnotationValue =>
      where((it) => it.id == nameAnnotationId).firstOrNull?.nameAnnotationValue;
}

extension on Annotation_Reader {
  String get nameAnnotationValue {
    assert(id == nameAnnotationId);

    if (value.which case Value_Which_Text_Reader(value: final name)) {
      if (name.isEmpty) {
        throw ArgumentError('`dart.name` annotation value must not be empty');
      } else if (_dartKeywordsToAvoid.contains(name)) {
        throw ArgumentError(
          '`dart.name` annotation value must not be a reserved Dart keyword, '
          'but is `$name`.',
        );
      } else if (!RegExp(r'^[A-Za-z0-9_]$').hasMatch(name)) {
        throw ArgumentError(
          '`dart.name` annotation value must only contain alphanumeric '
          'characters and `_`, but is `$name`.',
        );
      }
      return name;
    } else {
      throw ArgumentError('`dart.name` annotation value must be of type Text');
    }
  }
}

// https://dart.dev/language/keywords
//
// Keywords that “can be used as an identifier without restriction”:
// `async`, `base`, `hide`, `of`, `on`, `sealed`, `show`, `sync`, `when`
const _dartKeywordsToAvoid = {
  //
  'abstract', 'as', 'assert', 'await', 'break', 'case', 'catch', 'class',
  'const', 'continue', 'covariant', 'default', 'deferred', 'do', 'dynamic',
  'else', 'enum', 'export', 'extends', 'extension', 'external', 'factory',
  'false', 'final', 'finally', 'for', 'Function', 'get', 'if', 'implements',
  'import', 'in', 'interface', 'is', 'late', 'library', 'mixin', 'new', 'null',
  'operator', 'part', 'required', 'rethrow', 'return', 'set', 'static', 'super',
  'switch', 'this', 'throw', 'true', 'try', 'type', 'typedef', 'var', 'void',
  'with', 'while', 'yield',
};

extension on String {
  String capitalize() => substring(0, 1).toUpperCase() + substring(1);

  String avoidDartKeywords() =>
      _dartKeywordsToAvoid.contains(this) ? '${this}_' : this;
}

// Annotation IDs as defined in `dart.capnp`.
// ignore: avoid_js_rounded_ints
const nameAnnotationId = 0xec209b3bbf6afb0f;
// ignore: avoid_js_rounded_ints
const nullableAnnotationId = 0x8f48ef3fdb930cd2;
