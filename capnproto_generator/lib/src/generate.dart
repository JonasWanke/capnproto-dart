// ignore_for_file: lines_longer_than_80_chars

import 'dart:convert';
import 'dart:io';

import 'package:collection/collection.dart';
import 'package:dart_style/dart_style.dart';
import 'package:path/path.dart' as path;

import 'constants.dart';
import 'imports.dart';
import 'schema.capnp.dart';

class CodeGenerationCommand {
  /// [extraImports] is a map from import URI to the file IDs that the import
  /// provides generated code for.
  // TODO(JonasWanke): generate code for the JSON schema and update/add these docs
  // # Example
  //
  // If you write a schema like so:
  //
  // ```capnp
  // // my_schema.capnp
  // using Json = import "/capnp/compat/json.capnp";
  //
  // struct Foo {
  //     value @0 :Json.Value;
  // }
  // ```
  //
  // You'd look at [json.capnp][json.capnp] to see its Cap'n Proto ID:
  //
  // ```capnp
  // // json.capnp
  // # Copyright (c) 2015 Sandstorm Development Group, Inc. and contributors
  // @0x8ef99297a43a5e34;
  // ```
  //
  // If you want the `foo::Builder::get_value` method generated for your
  // schema to return a `capnp_json::json_capnp::value::Reader`, add a
  // dependency on `capnp_json` to your `Cargo.toml` and specify it provides
  // `json.capnp` in your `build.rs`.
  //
  // ```
  // // build.rs
  //
  // capnpc::CompilerCommand::new()
  //     .crate_provides("json_capnp", [0x8ef99297a43a5e34])
  //     .file("my_schema.capnp")
  //     .run()
  //     .unwrap();
  // ```
  //
  // [json.capnp]: https://github.com/capnproto/capnproto/blob/master/c%2B%2B/src/capnp/compat/json.capnp
  CodeGenerationCommand({
    Directory? outputDirectory,
    Map<Uri, List<int>> extraImports = const {},
  }) : this.raw(
          outputDirectory: outputDirectory,
          extraImports: Map.fromEntries(
            extraImports.entries.expand(
              (entry) => entry.value.map((it) => MapEntry(it, entry.key)),
            ),
          ),
        );
  CodeGenerationCommand.raw({
    Directory? outputDirectory,
    this.extraImports = const {},
  }) : outputDirectory = outputDirectory ?? Directory.current;

  final Directory outputDirectory;

  /// A map from file ID to the import URI that provides the corresponding code.
  ///
  /// You only need this when your generated code needs to refer to types in
  /// an external package. If you just want to use an annotation and the
  /// argument to that annotation is a built-in type (e.g. `$Json.name`), this
  /// isn't necessary.
  final Map<int, Uri> extraImports;

  Future<void> run(CodeGeneratorRequest_Reader request) async {
    final context = GeneratorContext(this, request);
    await request.requestedFiles.map(context.generateFile).wait;
  }
}

class GeneratorContext {
  GeneratorContext(this.command, this.request) {
    for (final node in request.nodes) {
      nodeMap[node.id] = (node: node, sourceInfo: null);
      nodeParents[node.id] = node.scopeId;
    }
    for (final sourceInfo in request.sourceInfo) {
      final data = nodeMap[sourceInfo.id];
      if (data == null) continue;

      nodeMap[sourceInfo.id] = (node: data.node, sourceInfo: sourceInfo);
    }

    // Fix up "anonymous" method params and results scopes.
    // for (final node in request.nodes) {
    //   if (node.which case final Node_interface_Reader interface) {
    //     for (final method in interface.methods) {
    //       final paramStructType = method.paramStructType;
    //       if (nodeParents[paramStructType] == 0) {
    //         nodeParents[paramStructType] = node.id;
    //       }
    //       final resultStructType = method.resultStructType;
    //       if (nodeParents[resultStructType] == 0) {
    //         nodeParents[resultStructType] = node.id;
    //       }
    //     }
    //   }
    // }

    for (final requestedFile in request.requestedFiles) {
      for (final import in requestedFile.imports) {
        if (command.extraImports[import.id] case final importUri?) {
          _populateImportsAndNames(importUri, import.id, '');
        }
      }

      _populateImportsAndNames(
        Uri.parse(requestedFile.dartFilename),
        requestedFile.id,
        '',
      );
    }
  }

  final CodeGenerationCommand command;
  final CodeGeneratorRequest_Reader request;
  final Map<int, ({Node_Reader node, Node_SourceInfo_Reader? sourceInfo})>
      nodeMap = {};

  /// Map from node ID to the node ID of its parent scope.
  ///
  /// This is equal to `node.scopeId` for all nodes except for autogenerated
  /// interface param and result structs: those have `scopeId` set to 0. See the
  /// comment on `paramStructType` in schema.capnp.
  final Map<int, int> nodeParents = {};

  final Map<int, ({Uri importUri, String name})> nodeImportsAndNames = {};

  void _populateImportsAndNames(Uri importUri, int nodeId, String nodeName) {
    // Unused nodes in imported files might be omitted from the node map;
    final data = nodeMap[nodeId];
    if (data == null) return;
    final (:node, sourceInfo: _) = data;

    final name = node.annotations
            .where((it) => it.id == nameAnnotationId)
            .firstOrNull
            ?.nameAnnotationValue ??
        nodeName;

    nodeImportsAndNames[nodeId] = (importUri: importUri, name: name);

    final nestedNamePrefix = name.isEmpty ? '' : '${name}_';
    if (node.which case final Node_struct_Reader struct) {
      for (final field in struct.fields) {
        if (field.which case final Field_group_Reader group) {
          final rawName =
              field.annotations.dartNameAnnotationValue ?? field.name;
          _populateImportsAndNames(
            importUri,
            group.typeId_,
            '$nestedNamePrefix$rawName',
          );
        }
      }
    }
    for (final nestedNode in node.nestedNodes) {
      _populateImportsAndNames(
        importUri,
        nestedNode.id,
        nestedNode.dartName(nestedNamePrefix).avoidDartKeywords(),
      );
    }
  }

  Future<void> generateFile(CodeGeneratorRequest_RequestedFile_Reader file) =>
      FileGenerator.generate(this, file);
}

class FileGenerator {
  FileGenerator._(this.context, Uri currentFile)
      : _imports = Imports(currentFile);

  static Future<void> generate(
    GeneratorContext context,
    CodeGeneratorRequest_RequestedFile_Reader file,
  ) async {
    final dartFile = File(
      path.join(context.command.outputDirectory.path, file.dartFilename),
    );
    await dartFile.parent.create(recursive: true);

    final generator = FileGenerator._(
      context,
      context.nodeImportsAndNames[file.id]!.importUri,
    );
    generator._generateNode(file.id);

    final output = StringBuffer();

    // We want to match this filter:
    // https://github.com/github-linguist/linguist/blob/1647b5be1658fb15a5e09bf89067f79b392301e2/lib/linguist/generated.rb#L712-L727
    output.writeln(
      '// GENERATED CODE - DO NOT MODIFY BY HAND\n'
      "// Generated by the capnpc-dart plugin to the Cap'n Proto schema compiler.\n"
      '// Source: ${file.filename}\n'
      '\n'
      '// ignore_for_file: avoid_js_rounded_ints, avoid_setters_without_getters\n'
      '// ignore_for_file: camel_case_types, directives_ordering\n'
      '// ignore_for_file: lines_longer_than_80_chars\n',
    );

    final codeBuffer = StringBuffer();

    generator._imports.addImportsToBuffer(codeBuffer);
    codeBuffer.writeln();
    for (final declarationBuffer in generator._declarations) {
      codeBuffer.writeln(declarationBuffer);
      codeBuffer.writeln();
    }
    final formatted = DartFormatter().format(codeBuffer.toString());
    output.write(formatted);

    await dartFile.writeAsString(output.toString());
  }

  final GeneratorContext context;

  final Imports _imports;
  final _declarations = <StringBuffer>[];
  StringBuffer _addDeclaration([String content = '']) {
    final buffer = StringBuffer(content);
    _declarations.add(buffer);
    return buffer;
  }

  void _generateNode(int nodeId, {String? superClass}) {
    final (:node, :sourceInfo) = context.nodeMap[nodeId]!;
    final name = context.nodeImportsAndNames[nodeId]!.name;

    final nestedNodes = node.nestedNodes.toList();
    void generateConstantsAsStatic(StringBuffer buffer) {
      for (var i = 0; i < nestedNodes.length; i++) {
        final nestedNode = nestedNodes[i];
        final (:node, :sourceInfo) = context.nodeMap[nestedNode.id]!;
        if (node.which case final Node_const_Reader constant) {
          _generateConstant(
            buffer,
            nestedNode.dartName().avoidDartKeywords(),
            constant.type,
            constant.value,
            docComment: sourceInfo?.docComment,
            isStatic: true,
          );
          buffer.writeln();
          nestedNodes.removeAt(i);
          i--;
        }
      }
    }

    switch (node.which) {
      case Node_file_Reader():
        break;

      case final Node_struct_Reader struct:
        final reader = _addDeclaration();
        final builder = _addDeclaration();

        reader.writeln(
          '// ${struct.isGroup ? 'group' : 'struct'} ${node.shortDisplayName}\n',
        );

        final (superClassReader, superClassBuilder) = superClass != null
            ? ('${superClass}_Reader', '${superClass}_Builder')
            : (_imports.capnpStructReader, _imports.capnpStructBuilder);

        reader.writeDocComment(sourceInfo?.docComment);
        reader.writeln(
          'class ${name}_Reader extends $superClassReader {\n'
          '  const ${name}_Reader(super.reader);\n',
        );

        reader.writeTypeId(node.id);

        generateConstantsAsStatic(reader);

        builder.writeDocComment(sourceInfo?.docComment);
        builder.writeln(
          'class ${name}_Builder extends $superClassBuilder<${name}_Reader> {\n'
          '  const ${name}_Builder(super.builder);\n'
          '\n'
          '  ${name}_Builder.initPointer(${_imports.pointerBuilder} builder)\n'
          '      : this(builder.initStruct(structSize));\n'
          '\n'
          '  ${name}_Builder.getFromPointer(\n'
          '    ${_imports.pointerBuilder} builder,\n'
          '    ${_imports.byteData} defaultValue,\n'
          '  ) : this(builder.getStruct(structSize, defaultValue).unwrap());\n'
          '\n'
          '  static const structSize = ${_imports.structSize}('
          '    dataWords: ${struct.dataWordCount},'
          '    pointerCount: ${struct.pointerCount}'
          '  );\n'
          '\n'
          '  @${_imports.override}\n'
          '  ${name}_Reader get asReader => ${name}_Reader(builder.asReader);\n',
        );
        generateConstantsAsStatic(reader);

        final unionFields = <(Field_Reader, String?)>[];

        for (final (index, field) in struct.fields.indexed) {
          final docComment = sourceInfo?.members[index].docComment;
          if (field.discriminantValue != Field_Reader.noDiscriminant) {
            unionFields.add((field, docComment));
            continue;
          }

          switch (field.which) {
            case final Field_slot_Reader slot:
              _generateField(
                reader,
                builder,
                field.dartName.avoidDartKeywords(),
                slot,
                readerClassName: '${name}_Reader',
                docComment: docComment,
              );

            case Field_group_Reader(:final typeId_):
              _generateNode(typeId_);

            case Field_notInSchema_Reader():
              throw UnsupportedError('Unknown field type');
          }

          reader.writeln();
          builder.writeln();
        }

        if (unionFields.isNotEmpty) {
          for (final (unionField, docComment) in unionFields) {
            switch (unionField.which) {
              case final Field_slot_Reader slot:
                _generateField(
                  reader,
                  builder,
                  unionField.dartName.avoidDartKeywords(),
                  slot,
                  readerClassName: '${name}_Reader',
                  discriminant: (
                    offset: struct.discriminantOffset,
                    value: unionField.discriminantValue,
                  ),
                  docComment: docComment,
                );

              case Field_group_Reader(:final typeId_):
                final (importUri: _, :name) =
                    context.nodeImportsAndNames[typeId_]!;
                builder.writeDocComment(docComment);
                builder.writeln(
                  '${name}_Builder init${unionField.name.capitalize()}() {\n'
                  '  builder.setUInt16(${struct.discriminantOffset}, ${unionField.discriminantValue}, 0);\n'
                  '  return ${name}_Builder(builder);\n'
                  '}',
                );

              case Field_notInSchema_Reader():
                throw UnsupportedError('Unknown field type');
            }
          }

          reader.writeln(
            '${name}_union_Reader get which {\n'
            '  return switch (reader.getUInt16(${struct.discriminantOffset}, 0)) {',
          );
          for (final (unionField, _) in unionFields) {
            final variantName = '${name}_${unionField.name}';
            reader.writeln(
              '${unionField.discriminantValue} => ${variantName}_Reader(reader),',
            );
          }
          reader.writeln(
            '    _ => ${name}_notInSchema_Reader(reader),\n'
            '  };\n'
            '}',
          );

          builder.writeln(
            '${name}_union_Builder get which {\n'
            '  return switch (builder.getUInt16(${struct.discriminantOffset}, 0)) {',
          );
          for (final (unionField, _) in unionFields) {
            final variantName = '${name}_${unionField.name}';
            builder.writeln(
              '${unionField.discriminantValue} => ${variantName}_Builder(builder),',
            );
          }
          builder.writeln(
            '    _ => ${name}_notInSchema_Builder(builder),\n'
            '  };\n'
            '}',
          );
        }

        reader.writeln('}');
        builder.writeln('}');

        if (unionFields.isNotEmpty) {
          assert(unionFields.length >= 2);
          assert(unionFields.length == struct.discriminantCount);

          reader.writeln(
            'sealed class ${name}_union_Reader '
            '    extends ${_imports.capnpStructReader} {\n'
            '  const ${name}_union_Reader(super.reader);\n'
            '}',
          );

          builder.writeln(
            'sealed class ${name}_union_Builder<R extends ${name}_union_Reader> '
            '    extends ${_imports.capnpStructBuilder}<R> {\n'
            '  const ${name}_union_Builder(super.builder);\n'
            '}',
          );

          for (final (unionField, docComment) in unionFields) {
            switch (unionField.which) {
              case final Field_slot_Reader slot:
                final variantName = '${name}_${unionField.dartName}';
                final reader = _addDeclaration();
                final builder = _addDeclaration();

                reader.writeDocComment(docComment);
                reader.writeln(
                  'class ${variantName}_Reader extends ${name}_union_Reader {\n'
                  '  const ${variantName}_Reader(super.reader);\n',
                );

                builder.writeDocComment(docComment);
                builder.writeln(
                  'class ${variantName}_Builder extends ${name}_union_Builder {\n'
                  '  const ${variantName}_Builder(super.builder);\n'
                  '\n'
                  '  @${_imports.override}\n'
                  '  ${variantName}_Reader get asReader =>'
                  '      ${variantName}_Reader(builder.asReader);\n'
                  '\n',
                );

                _generateField(
                  reader,
                  builder,
                  'value',
                  slot,
                  readerClassName: '${variantName}_Reader',
                  docComment: null,
                );

                reader.writeln('}');
                builder.writeln('}');

              case Field_group_Reader(:final typeId_):
                _generateNode(typeId_, superClass: '${name}_union');

              case Field_notInSchema_Reader():
                throw UnsupportedError('Unknown field type');
            }
          }

          _addDeclaration(
            'class ${name}_notInSchema_Reader extends ${name}_union_Reader {\n'
            '  const ${name}_notInSchema_Reader(super.reader);\n'
            '}',
          );
          _addDeclaration(
            'class ${name}_notInSchema_Builder extends ${name}_union_Builder {\n'
            '  const ${name}_notInSchema_Builder(super.builder);\n'
            '\n'
            '  @${_imports.override}\n'
            '  ${name}_notInSchema_Reader get asReader =>'
            '      ${name}_notInSchema_Reader(builder.asReader);\n'
            '}',
          );
        }

      case final Node_enum_Reader enum_:
        final buffer = _addDeclaration();
        buffer.writeln('// enum ${node.shortDisplayName}');
        buffer.writeln();

        buffer.writeDocComment(sourceInfo?.docComment);
        buffer.writeln('enum $name {');
        for (final (value, entry) in enum_.enumerants.indexed) {
          buffer.writeDocComment(sourceInfo?.members[value].docComment);
          buffer.writeln('${entry.dartName.avoidDartKeywords()}($value),');
        }
        buffer.writeln('notInSchema(null);');
        buffer.writeln();

        buffer.writeln('const $name(this.value);');
        buffer.writeln();

        buffer.writeln('factory $name.fromValue(${_imports.int} value) {');
        buffer.writeln('return switch (value) {');
        for (final (value, entry) in enum_.enumerants.indexed) {
          buffer.writeln(
            '$value => $name.${entry.dartName.avoidDartKeywords()},',
          );
        }
        buffer.writeln('_ => $name.notInSchema,');
        buffer.writeln('};');
        buffer.writeln('}');
        buffer.writeln();

        buffer.writeTypeId(node.id);

        generateConstantsAsStatic(buffer);

        buffer.writeln('final ${_imports.int}? value;');
        buffer.writeln('}');

      case Node_interface_Reader():
        _addDeclaration('// TODO: codegen for interface');

      case Node_const_Reader(:final type, :final value):
        final buffer = _addDeclaration();
        _generateConstant(
          buffer,
          name,
          type,
          value,
          docComment: sourceInfo?.docComment,
          isStatic: false,
        );

      case Node_annotation_Reader():
        break;

      case Node_notInSchema_Reader():
        throw UnsupportedError('Unknown node type');
    }

    for (final nestedNode in nestedNodes) {
      _generateNode(nestedNode.id);
    }
  }

  void _generateField(
    StringBuffer reader_,
    StringBuffer builder_,
    String name,
    Field_slot_Reader slot, {
    required String readerClassName,
    ({int offset, int value})? discriminant,
    required String? docComment,
  }) {
    final reader = discriminant == null ? reader_ : null;
    final builderGetters = discriminant == null ? builder_ : null;
    final builderSetters = builder_;

    final discriminantMatchesAnd = discriminant == null
        ? ''
        : 'builder.getUInt16(${discriminant.offset}, 0) == ${discriminant.value} && ';
    final setDiscriminant = discriminant == null
        ? ''
        : 'builder.setUInt16(${discriminant.offset}, ${discriminant.value}, 0);\n';

    void generateHas() {
      reader?.writeln(
        '${_imports.bool} get has${name.capitalize()} => '
        '!reader.getPointer(${slot.offset}).isNull;',
      );

      builderSetters.writeln(
        '${_imports.bool} get has${name.capitalize()} =>'
        '    $discriminantMatchesAnd !builder.getPointer(${slot.offset}).isNull;',
      );
    }

    final defaultName = 'default${name.capitalize()}';
    final hasExplicitDefault = slot.hadExplicitDefault &&
        reader != null &&
        _generateConstant(
          reader,
          defaultName,
          slot.type,
          slot.defaultValue,
          isStatic: true,
          docComment: 'Default value of [$name].',
          onlyIfNotDefault: true,
        );
    final (defaultValue, defaultValueFromBuilder) = hasExplicitDefault
        ? (defaultName, '$readerClassName.$defaultName')
        : (null, null);

    void generatePrimitiveField(
      String dartType,
      String capnpType,
      String defaultDefaultValue, {
      String? defaultDefaultValueFromBuilder,
    }) {
      reader?.writeDocComment(docComment);
      reader?.writeln(
        '$dartType get $name =>'
        '  reader.get$capnpType(${slot.offset}, ${defaultValue ?? defaultDefaultValue});',
      );

      final defaultFromBuilder = defaultValueFromBuilder ??
          defaultDefaultValueFromBuilder ??
          defaultDefaultValue;
      builderSetters.writeDocComment(docComment);
      builderGetters?.writeln(
        '$dartType get $name {\n'
        '  $setDiscriminant'
        '  return builder.get$capnpType(${slot.offset}, $defaultFromBuilder);\n'
        '}',
      );
      builderSetters.writeln(
        'set $name($dartType value) {\n'
        '  $setDiscriminant'
        '  return builder.set$capnpType(${slot.offset}, value, $defaultFromBuilder);\n'
        '}',
      );
    }

    switch (slot.type.which) {
      case Type_void_Reader():
        reader?.writeDocComment(docComment);
        reader?.writeln('void get $name {}');

        builderSetters.writeDocComment(docComment);
        builderGetters?.writeln('void get $name {}');
        if (setDiscriminant.isNotEmpty) {
          builderSetters.writeln(
            'void set${name.capitalize()}() {\n'
            '  $setDiscriminant'
            '}',
          );
        }

      case Type_bool_Reader():
        generatePrimitiveField(_imports.bool, 'Bool', 'false');

      case Type_int8_Reader():
        generatePrimitiveField(_imports.int, 'Int8', '0');
      case Type_int16_Reader():
        generatePrimitiveField(_imports.int, 'Int16', '0');
      case Type_int32_Reader():
        generatePrimitiveField(_imports.int, 'Int32', '0');
      case Type_int64_Reader():
        generatePrimitiveField(_imports.int, 'Int64', '0');
      case Type_uint8_Reader():
        generatePrimitiveField(_imports.int, 'UInt8', '0');
      case Type_uint16_Reader():
        generatePrimitiveField(_imports.int, 'UInt16', '0');
      case Type_uint32_Reader():
        generatePrimitiveField(_imports.int, 'UInt32', '0');
      case Type_uint64_Reader():
        generatePrimitiveField(_imports.int, 'UInt64', '0');

      case Type_float32_Reader():
        generatePrimitiveField(
          _imports.double,
          'Float32',
          defaultValue == null ? '0' : '_${defaultValue}Bits',
          defaultDefaultValueFromBuilder: defaultValue == null
              ? '0'
              : '$readerClassName._${defaultValue}Bits',
        );
      case Type_float64_Reader():
        generatePrimitiveField(
          _imports.double,
          'Float64',
          defaultValue == null ? '0' : '_${defaultValue}Bits',
          defaultDefaultValueFromBuilder: defaultValue == null
              ? '0'
              : '$readerClassName._${defaultValue}Bits',
        );

      case Type_text_Reader():
        generateHas();

        reader?.writeDocComment(docComment);
        reader?.writeln(
          '${_imports.string} get $name =>'
          '  reader.getPointer(${slot.offset}).getText($defaultValue).unwrap();',
        );

        builderSetters.writeDocComment(docComment);
        builderGetters?.writeln(
          '${_imports.string} get $name =>'
          '  builder.getPointer(${slot.offset}).getText($defaultValue).unwrap();',
        );
        builderSetters.writeln(
          'set $name(${_imports.string} value) {\n'
          '  $setDiscriminant'
          '  builder.getPointer(${slot.offset}).setText(value);\n'
          '}',
        );
      case Type_data_Reader():
        generateHas();

        reader?.writeDocComment(docComment);
        reader?.writeln(
          '${_imports.byteData} get $name =>'
          '  reader.getPointer(${slot.offset}).getData($defaultValue).unwrap();',
        );

        builderSetters.writeDocComment(docComment);
        builderGetters?.writeln(
          '${_imports.byteData} get $name =>'
          '  builder.getPointer(${slot.offset}).getData($defaultValue).unwrap();',
        );
        builderSetters.writeln(
          'set $name(${_imports.byteData} value) {\n'
          '  $setDiscriminant'
          '  builder.getPointer(${slot.offset}).setData(value);\n'
          '}',
        );

      case Type_list_Reader(:final elementType):
        generateHas();

        reader?.writeDocComment(docComment);
        builderSetters.writeDocComment(docComment);

        void generatePrimitiveList(String dartType, String capnpType) {
          reader?.writeln(
            '${_imports.primitiveListReader}<$dartType> get $name =>'
            '  ${_imports.primitiveListReader}.${capnpType}GetFromPointer(reader.getPointer(${slot.offset}), $defaultValue).unwrap();',
          );

          builderGetters?.writeln(
            '${_imports.primitiveListBuilder}<$dartType> get $name =>'
            '  ${_imports.primitiveListBuilder}.${capnpType}GetFromPointer(builder.getPointer(${slot.offset}), $defaultValue).unwrap();',
          );
          builderSetters.writeln(
            'void init${name.capitalize()}(${_imports.int} length) {\n'
            '  $setDiscriminant'
            '  ${_imports.primitiveListBuilder}.${capnpType}InitPointer(builder.getPointer(${slot.offset}), length);\n'
            '}',
          );
        }
        switch (elementType.which) {
          case Type_void_Reader():
            generatePrimitiveList('void', 'void');
          case Type_bool_Reader():
            generatePrimitiveList('bool', 'bool');
          case Type_int8_Reader():
            generatePrimitiveList('int', 'int8');
          case Type_int16_Reader():
            generatePrimitiveList('int', 'int16');
          case Type_int32_Reader():
            generatePrimitiveList('int', 'int32');
          case Type_int64_Reader():
            generatePrimitiveList('int', 'int64');
          case Type_uint8_Reader():
            generatePrimitiveList('int', 'uint8');
          case Type_uint16_Reader():
            generatePrimitiveList('int', 'uint16');
          case Type_uint32_Reader():
            generatePrimitiveList('int', 'uint32');
          case Type_uint64_Reader():
            generatePrimitiveList('int', 'uint64');
          case Type_float32_Reader():
            generatePrimitiveList('double', 'float32');
          case Type_float64_Reader():
            generatePrimitiveList('double', 'float64');
          case Type_text_Reader():
            reader?.writeln(
              '${_imports.textListReader} get $name =>'
              '  ${_imports.textListReader}.getFromPointer(reader.getPointer(${slot.offset}), $defaultValue).unwrap();',
            );

            builderGetters?.writeln(
              '${_imports.textListBuilder} get $name =>'
              '  ${_imports.textListBuilder}.getFromPointer(builder.getPointer(${slot.offset}), $defaultValue).unwrap();',
            );
            builderSetters.writeln(
              '${_imports.textListBuilder} init${name.capitalize()} {\n'
              '  $setDiscriminant'
              '  return ${_imports.textListBuilder}.initFromPointer(builder.getPointer(${slot.offset}), length);\n'
              '}',
            );
          case Type_data_Reader():
            reader?.writeln(
              '${_imports.dataListReader} get $name =>'
              '  ${_imports.dataListReader}.getFromPointer(reader.getPointer(${slot.offset}), $defaultValue).unwrap();',
            );

            builderGetters?.writeln(
              '${_imports.dataListBuilder} get $name =>'
              '  ${_imports.dataListBuilder}.getFromPointer(builder.getPointer(${slot.offset}), $defaultValue).unwrap();',
            );
            builderSetters.writeln(
              '${_imports.dataListBuilder} init${name.capitalize()} {\n'
              '  $setDiscriminant'
              '  return ${_imports.dataListBuilder}.initFromPointer(builder.getPointer(${slot.offset}), length);\n'
              '}',
            );
          case Type_list_Reader():
            reader?.writeln('// TODO: codegen field of type list of list');
            builderSetters
                .writeln('// TODO: codegen field of type list of list');
          case Type_enum_Reader():
            reader?.writeln('// TODO: codegen field of type list of enum');
            builderSetters
                .writeln('// TODO: codegen field of type list of enum');
          case Type_struct_Reader(:final typeId_):
            final elementType = context.nodeImportsAndNames[typeId_]!;
            final elementTypeString =
                _imports.import(elementType.importUri, elementType.name);
            final listReaderClass = _imports.structListReader;
            reader?.writeln(
              '$listReaderClass<${elementTypeString}_Reader> get $name {\n'
              '  return $listReaderClass.getFromPointer(\n'
              '    reader.getPointer(${slot.offset}),\n'
              '    ${elementTypeString}_Reader.new,\n'
              '    $defaultValue,\n'
              '  ).unwrap();\n'
              '}',
            );

            final listBuilderClass = _imports.structListBuilder;
            final listBuilder =
                '$listBuilderClass<${elementTypeString}_Builder, ${elementTypeString}_Reader>';
            builderGetters?.writeln(
              '$listBuilder get $name {\n'
              '  return $listBuilderClass.getFromPointer(\n'
              '    builder.getPointer(${slot.offset}),\n'
              '    ${elementTypeString}_Builder.structSize,\n'
              '    ${elementTypeString}_Builder.new,\n'
              '    ${elementTypeString}_Reader.new,\n'
              '    $defaultValue,\n'
              '  ).unwrap();\n'
              '}\n',
            );
            builderSetters.writeln(
              '$listBuilder init${name.capitalize()}(${_imports.int} length) {\n'
              '  $setDiscriminant'
              '  return $listBuilderClass.initPointer(\n'
              '    builder.getPointer(${slot.offset}),\n'
              '    length,\n'
              '    ${elementTypeString}_Builder.structSize,\n'
              '    ${elementTypeString}_Builder.new,\n'
              '    ${elementTypeString}_Reader.new,\n'
              '  );\n'
              '}',
            );

          case Type_interface_Reader():
            reader?.writeln('// TODO: codegen field of type list of interface');
            builderSetters
                .writeln('// TODO: codegen field of type list of interface');
          case Type_anyPointer_Reader():
            reader
                ?.writeln('// TODO: codegen field of type list of AnyPointer');
            builderSetters
                .writeln('// TODO: codegen field of type list of AnyPointer');
          case Type_notInSchema_Reader():
            throw UnsupportedError('Unknown list element type');
        }

      case Type_enum_Reader(:final typeId_):
        final (:importUri, name: enumName) =
            context.nodeImportsAndNames[typeId_]!;
        final enum_ = _imports.import(importUri, enumName);
        final enumDefaultValue =
            defaultValue != null ? '$defaultValue.value!' : 0;

        reader?.writeDocComment(docComment);
        reader?.writeln(
          '$enum_ get $name => $enum_.fromValue(reader.getUInt16(${slot.offset}, $enumDefaultValue));',
        );

        builderGetters?.writeDocComment(docComment);
        builderGetters?.writeln(
          '$enum_ get $name => $enum_.fromValue(builder.getUInt16(${slot.offset}, $enumDefaultValue));',
        );
        builderSetters.writeln(
          'void set $name($enum_ value) {\n'
          '  assert(value != $enum_.notInSchema);\n'
          '  $setDiscriminant'
          '  builder.setUInt16(${slot.offset}, value.value!, $enumDefaultValue);\n'
          '}',
        );

      case Type_struct_Reader(:final typeId_):
        generateHas();

        final type = context.nodeImportsAndNames[typeId_]!;
        final typeString = _imports.import(type.importUri, type.name);

        reader?.writeDocComment(docComment);
        reader?.writeln(
          '${typeString}_Reader get $name =>'
          '  ${typeString}_Reader(reader.getPointer(${slot.offset}).getStruct($defaultValue).unwrap());',
        );

        builderSetters.writeDocComment(docComment);
        builderGetters?.writeln(
          '${typeString}_Builder get${name.capitalize()}() {\n'
          '  return ${typeString}_Builder(\n'
          '    builder.getPointer(${slot.offset})\n'
          '      .getStruct(${typeString}_Builder.structSize, $defaultValue)\n'
          '      .unwrap(),\n'
          '  );\n'
          '}',
        );
        builderSetters.writeln(
          '${typeString}_Builder init${name.capitalize()}() {\n'
          '  $setDiscriminant'
          '  return ${typeString}_Builder(builder.getPointer(${slot.offset}).initStruct(${typeString}_Builder.structSize));\n'
          '}',
        );

      case Type_interface_Reader():
        reader?.writeln('// TODO: codegen for interface-typed field');
        builderSetters.writeln('// TODO: codegen for interface-typed field');

      case Type_anyPointer_Reader():
        if (defaultValue != null) {
          throw UnsupportedError(
            'Default value for AnyPointer-typed field is unsupported',
          );
        }

        generateHas();

        reader?.writeDocComment(docComment);
        reader?.writeln(
          '${_imports.anyPointerReader} get $name =>'
          '  ${_imports.anyPointerReader}(reader.getPointer(${slot.offset}));',
        );

        builderSetters.writeDocComment(docComment);
        builderSetters.writeln(
          '${_imports.anyPointerBuilder} init${name.capitalize()}() {\n'
          '  $setDiscriminant'
          '  final result = ${_imports.anyPointerBuilder}(builder.getPointer(${slot.offset}));\n'
          '  result.clear();\n'
          '  return result;\n'
          '}',
        );

      default:
        throw ArgumentError("Field's type and default value don't match.");
    }
  }

  bool _generateConstant(
    StringBuffer buffer,
    String name,
    Type_Reader type,
    Value_Reader value, {
    required String? docComment,
    required bool isStatic,
    bool onlyIfNotDefault = false,
  }) {
    final staticString = isStatic ? 'static' : '';

    switch ((type.which, value.which)) {
      case (Type_void_Reader(), Value_void_Reader()):
        if (onlyIfNotDefault) return false;

        buffer.writeDocComment(docComment);
        buffer.writeln('$staticString const $name = null;');

      case (Type_bool_Reader(), Value_bool_Reader(:final value)):
        // ignore: no_literal_bool_comparisons, no-boolean-literal-compare
        if (onlyIfNotDefault && value == false) return false;

        buffer.writeDocComment(docComment);
        buffer.writeln('$staticString const $name = $value;');

      case (Type_int8_Reader(), Value_int8_Reader(:final num value)) ||
            (Type_int16_Reader(), Value_int16_Reader(:final num value)) ||
            (Type_int32_Reader(), Value_int32_Reader(:final num value)) ||
            (Type_int64_Reader(), Value_int64_Reader(:final num value)) ||
            (Type_uint8_Reader(), Value_uint8_Reader(:final num value)) ||
            (Type_uint16_Reader(), Value_uint16_Reader(:final num value)) ||
            (Type_uint32_Reader(), Value_uint32_Reader(:final num value)) ||
            (Type_uint64_Reader(), Value_uint64_Reader(:final num value)):
        if (onlyIfNotDefault && value == 0) return false;

        buffer.writeDocComment(docComment);
        buffer.writeln('$staticString const $name = $value;');

      case (
          Type_float32_Reader(),
          Value_float32_Reader(:final reader, :final num value),
        ):
        if (onlyIfNotDefault && value == 0) return false;

        buffer.writeDocComment(docComment);
        buffer.writeln('$staticString const $name = $value;');
        buffer.writeln(
          '$staticString final _${name}Bits = ${reader.getUInt32(1, 0).toRadixString(16).padLeft(8, '0')};',
        );
      case (
          Type_float64_Reader(),
          Value_float64_Reader(:final reader, :final num value),
        ):
        if (onlyIfNotDefault && value == 0) return false;

        buffer.writeDocComment(docComment);
        buffer.writeln('$staticString const $name = $value;');
        buffer.writeln(
          '$staticString final _${name}Bits = ${reader.getUInt32(1, 0).toRadixString(16).padLeft(16, '0')};',
        );

      case (Type_text_Reader(), Value_text_Reader(:final value)):
        if (onlyIfNotDefault && value == '') return false;

        buffer.writeDocComment(docComment);
        buffer.writeln(
          '$staticString const $name = '
          "'${value.replaceAll("'", r"\'").replaceAll('\n', r'\n')}';",
        );

      case (Type_data_Reader(), Value_data_Reader(:final value)):
        if (onlyIfNotDefault && value.lengthInBytes == 0) return false;

        generateConstantData(name, value, buffer, isStatic: isStatic);

      case (Type_enum_Reader(:final typeId_), Value_enum_Reader(:final value)):
        if (onlyIfNotDefault && value == 0) return false;

        final type = context.nodeMap[typeId_]!.node;
        final enumType = context.nodeImportsAndNames[typeId_]!;
        final enumTypeString =
            _imports.import(enumType.importUri, enumType.name);

        if (type.which case final Node_enum_Reader enum_) {
          final enumerant = enum_.enumerants[value];
          buffer.writeDocComment(docComment);
          buffer.writeln(
            '$staticString const $name = $enumTypeString.${enumerant.name};',
          );
        } else {
          throw ArgumentError('Type is not an enum');
        }

      case (
          Type_list_Reader(:final elementType),
          Value_list_Reader(:final value),
        ):
        final reference = generateConstantPointerReader(
          name,
          value,
          buffer,
          isStatic: isStatic,
        );

        buffer.writeDocComment(docComment);
        buffer.write('$staticString final $name = ');
        void generatePrimitiveList(String capnpType) {
          buffer.writeln(
            '${_imports.primitiveListReader}.${capnpType}FromPointer($reference, null).unwrap();',
          );
        }
        switch (elementType.which) {
          case Type_void_Reader():
            generatePrimitiveList('void');
          case Type_bool_Reader():
            generatePrimitiveList('bool');
          case Type_int8_Reader():
            generatePrimitiveList('int8');
          case Type_int16_Reader():
            generatePrimitiveList('int16');
          case Type_int32_Reader():
            generatePrimitiveList('int32');
          case Type_int64_Reader():
            generatePrimitiveList('int64');
          case Type_uint8_Reader():
            generatePrimitiveList('uint8');
          case Type_uint16_Reader():
            generatePrimitiveList('uint16');
          case Type_uint32_Reader():
            generatePrimitiveList('uint32');
          case Type_uint64_Reader():
            generatePrimitiveList('uint64');
          case Type_float32_Reader():
            generatePrimitiveList('float32');
          case Type_float64_Reader():
            generatePrimitiveList('float64');
          case Type_text_Reader():
            buffer.writeln(
              '${_imports.textListReader}.getFromPointer($reference, null).unwrap();',
            );
          case Type_data_Reader():
            buffer.writeln(
              '${_imports.dataListReader}.getFromPointer($reference, null).unwrap();',
            );
          case Type_list_Reader():
            buffer.writeln('// TODO: codegen field of type list of list');
          case Type_enum_Reader():
            buffer.writeln('// TODO: codegen field of type list of enum');
          case Type_struct_Reader(:final typeId_):
            final elementType = context.nodeImportsAndNames[typeId_]!;
            final elementTypeString =
                _imports.import(elementType.importUri, elementType.name);
            final listType = _imports.structListReader;
            buffer.writeln(
              '$listType.fromPointer($reference, ${elementTypeString}_Reader.new, null).unwrap();',
            );

          case Type_interface_Reader():
            buffer.writeln(
              '// TODO: codegen field of type list of interface',
            );
          case Type_anyPointer_Reader():
            buffer.writeln(
              '// TODO: codegen field of type list of AnyPointer',
            );
          case Type_notInSchema_Reader():
            throw UnsupportedError('Unknown list element type');
        }

      case (
          Type_struct_Reader(:final typeId_),
          Value_struct_Reader(:final value),
        ):
        final reference = generateConstantPointerReader(
          name,
          value,
          buffer,
          isStatic: isStatic,
        );

        final type = context.nodeImportsAndNames[typeId_]!;
        final typeString = _imports.import(type.importUri, type.name);
        buffer.writeDocComment(docComment);
        buffer.writeln(
          '$staticString final $name = '
          '${typeString}_Reader($reference.getStruct(null).unwrap());',
        );

      case (Type_interface_Reader(), Value_interface_Reader()):
        return false;

      case (Type_anyPointer_Reader(), Value_anyPointer_Reader(:final value)):
        final reference = generateConstantPointerReader(
          name,
          value,
          buffer,
          isStatic: isStatic,
        );

        buffer.writeDocComment(docComment);
        buffer.writeln(
          '$staticString final $name = '
          '${_imports.anyPointerReader}($reference);',
        );

      case (Type_notInSchema_Reader(), Value_notInSchema_Reader()):
        throw UnimplementedError('Interface constants are not yet supported');

      default:
        throw ArgumentError("Type and value don't match.");
    }
    return true;
  }
}

extension on CodeGeneratorRequest_RequestedFile_Reader {
  String get dartFilename => '$filename.dart';
}

extension on Node_Reader {
  String get shortDisplayName =>
      displayName.substring(displayName.lastIndexOf(':') + 1);
}

extension on Node_NestedNode_Reader {
  String dartName([String prefix = '']) => '$prefix$name';
}

extension on Enumerant_Reader {
  String get dartName => annotations.dartNameAnnotationValue ?? name;
}

extension on Field_Reader {
  String get dartName => annotations.dartNameAnnotationValue ?? name;
}

extension on Iterable<Annotation_Reader> {
  String? get dartNameAnnotationValue =>
      where((it) => it.id == nameAnnotationId).firstOrNull?.nameAnnotationValue;
}

extension on Annotation_Reader {
  String get nameAnnotationValue {
    assert(id == nameAnnotationId);

    if (value.which case Value_text_Reader(value: final name)) {
      if (name.isEmpty) {
        throw ArgumentError('`dart.name` annotation value must not be empty');
      } else if (_dartKeywordsToAvoid.contains(name)) {
        throw ArgumentError(
          '`dart.name` annotation value must not be a reserved Dart keyword, '
          'but is `$name`.',
        );
      } else if (!RegExp(r'^[A-Za-z0-9_]$').hasMatch(name)) {
        throw ArgumentError(
          '`dart.name` annotation value must only contain alphanumeric '
          'characters and `_`, but is `$name`.',
        );
      }
      return name;
    } else {
      throw ArgumentError('`dart.name` annotation value must be of type Text');
    }
  }
}

// https://dart.dev/language/keywords
//
// Keywords that “can be used as an identifier without restriction”:
// `async`, `base`, `hide`, `of`, `on`, `sealed`, `show`, `sync`, `when`
const _dartKeywordsToAvoid = {
  // Dart keywords:
  'abstract', 'as', 'assert', 'await', 'break', 'case', 'catch', 'class',
  'const', 'continue', 'covariant', 'default', 'deferred', 'do', 'dynamic',
  'else', 'enum', 'export', 'extends', 'extension', 'external', 'factory',
  'false', 'final', 'finally', 'for', 'Function', 'get', 'if', 'implements',
  'import', 'in', 'interface', 'is', 'late', 'library', 'mixin', 'new', 'null',
  'operator', 'part', 'required', 'rethrow', 'return', 'set', 'static', 'super',
  'switch', 'this', 'throw', 'true', 'try', 'typedef', 'var', 'void', 'with',
  'while', 'yield',
  // Generated by us:
  'typeId',
};

extension on String {
  String capitalize() => substring(0, 1).toUpperCase() + substring(1);

  String avoidDartKeywords() =>
      _dartKeywordsToAvoid.contains(this) ? '${this}_' : this;
}

extension on StringBuffer {
  void writeDocComment(String? content) {
    if (content == null) return;

    for (final line in const LineSplitter().convert(content)) {
      writeln('/// $line');
    }
  }

  void writeTypeId(int typeId) {
    // TODO(JonasWanke): encode as hex, but the following fails for negative numbers
    // typeId.toRadixString(16).padLeft(16, '0')
    writeln('static const typeId = $typeId;\n');
  }
}

// Annotation IDs as defined in `dart.capnp`.
// ignore: avoid_js_rounded_ints
const nameAnnotationId = 0xec209b3bbf6afb0f;
// ignore: avoid_js_rounded_ints
const nullableAnnotationId = 0x8f48ef3fdb930cd2;
