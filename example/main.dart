// ignore_for_file: avoid_print

import 'dart:io';
import 'dart:typed_data';

import 'package:capnproto/capnproto.dart';

void main() {
  // Read the compiled example message:
  final compiledFile = File('example/message.bin');
  print(compiledFile.absolute.path);
  final data = compiledFile.readAsBytesSync();
  final message = Message.fromBuffer(data.buffer);

  // And decode it:
  final testStruct = message.getRoot(TestStruct.new);
  print(testStruct);
}

// For every struct in your Cap'n Proto definitions, create a class like this:
class TestStruct extends Struct {
  // Create a constructor like the following:
  const TestStruct(super.reader);

  // Write a getter for each member. They delegate to getters on `reader`,
  // an accessor of the underlying buffer.
  //
  // The offsets are generated by Cap'n Proto if you execute the following
  // command:
  //
  // > capnp compile -ocapnp main.capnp > main-compiled.capnp
  //
  // (Where `main.capnp` is your source file and `main-compiled.capnp` gets
  // generated.)
  //
  // You then fill in the offsets for every getter as follows:
  //
  // * don't write a field for `Void`
  // * bits for `Bool`
  //   E.g., the generated line for the field `boolean` looks like:
  //   boolean @1 :Bool;  # bits[0, 1)
  //                             ^ You want this number.
  // * bytes for other primitives (i.e., numbers)
  //   E.g., the generated line for the field `int8` looks like:
  //   int8 @3 :Int8;  # bits[8, 16)
  //                          ^ You want this number, divided by eight (or
  //                            `CapnpConstants.bitsPerByte`). `TODO`
  //   Hence: ``
  // * `dataSectionLengthInWords + <pointerIndex>` for nested structs and lists.
  //   E.g., the generated line for the field `float32List` looks like:
  //   float32List @13 :List(Float32);  # ptr[2]
  //                                          ^ You want this number.
  //   Hence: `reader.getFloat32List(dataSectionLengthInWords + 2)`
  //
  // For inner structs and lists of structs, you also have to pass in a
  // `StructFactory`, which is used to actually instantiate those structs. This
  // is why we wrote the static function `from` above.

  bool get boolean => reader.getBool(0);
  BoolList get booleanList => reader.getBoolList(0);
  int get int8 => reader.getInt8(1);
  int get int16 => reader.getInt16(1);
  int get int32 => reader.getInt32(1);
  int get int64 => reader.getInt64(1);
  int get uint8 => reader.getUInt8(16);
  int get uint16 => reader.getUInt16(9);
  Uint16List get uint16List => reader.getUInt16List(1);
  int get uint32 => reader.getUInt32(5);
  int get uint64 => reader.getUInt64(3);
  double get float32 => reader.getFloat32(8);
  Float32List get float32List => reader.getFloat32List(2);
  double get float64 => reader.getFloat64(5);
  String get text => reader.getText(3);
  Uint8List get data => reader.getData(4);
  Foo get foo => reader.getStruct(5, Foo.new);
  CompositeList<Foo> get fooList => reader.getCompositeList(6, Foo.new);

  // This is optional:
  @override
  String toString() {
    return 'TestStruct(unit: <void>, boolean: $boolean, '
        'booleanList: $booleanList, int8: $int8, int16: $int16, int32: $int32, '
        'int64: $int64, uint8: $uint8, uint16: $uint16, '
        'uint16List: $uint16List, uint32: $uint32, uint64: $uint64, '
        'float32: $float32, float32List: $float32List, float64: $float64, '
        'text: $text, data: $data, foo: $foo, fooList: $fooList)';
  }
}

class Foo extends Struct {
  const Foo(super.reader);

  int get bar => reader.getUInt8(0);

  @override
  String toString() => 'Foo(bar: $bar)';
}
